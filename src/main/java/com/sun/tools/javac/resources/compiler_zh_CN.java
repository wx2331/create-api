/*   */ package com.sun.tools.javac.resources;
/*   */ 
/*   */ public final class compiler_zh_CN extends ListResourceBundle {
/*   */   protected final Object[][] getContents() {
/* 5 */     return new Object[][] { { "compiler.err.abstract.cant.be.accessed.directly", "无法直接访问{2}中的抽象{0} {1}" }, { "compiler.err.abstract.cant.be.instantiated", "{0}是抽象的; 无法实例化" }, { "compiler.err.abstract.meth.cant.have.body", "抽象方法不能有主体" }, { "compiler.err.already.annotated", "{0} {1}已进行注释" }, { "compiler.err.already.defined", "已在{2} {3}中定义了{0} {1}" }, { "compiler.err.already.defined.in.clinit", "已在{3} {4}的{2}中定义了{0} {1}" }, { "compiler.err.already.defined.single.import", "{0}的 single-type-import 已定义具有相同简名的类型" }, { "compiler.err.already.defined.static.single.import", "{0}的静态 single-type-import 已定义具有相同简名的类型" }, { "compiler.err.already.defined.this.unit", "已在该编译单元中定义{0}" }, { "compiler.err.annotation.missing.default.value", "对于元素 ''{1}'', 注释 @{0} 缺少默认值" }, { "compiler.err.annotation.missing.default.value.1", "对于元素{1}, 注释 @{0} 缺少默认值" }, { "compiler.err.annotation.not.valid.for.type", "注释对于类型{0}的元素无效" }, { "compiler.err.annotation.type.not.applicable", "注释类型不适用于该类型的声明" }, { "compiler.err.annotation.value.must.be.annotation", "注释值必须为注释" }, { "compiler.err.annotation.value.must.be.class.literal", "注释值必须为类文字" }, { "compiler.err.annotation.value.must.be.name.value", "注释值必须采用 ''name=value'' 格式" }, { "compiler.err.annotation.value.not.allowable.type", "注释值不是允许的类型" }, { "compiler.err.annotations.after.type.params.not.supported.in.source", "-source {0} 中不支持方法类型参数后的注释\n(请使用 -source 8 或更高版本以启用方法类型参数后的注释)" }, { "compiler.err.annotations.not.supported.in.source", "-source {0} 中不支持注释\n(请使用 -source 5 或更高版本以启用注释)" }, { "compiler.err.anon.class.impl.intf.no.args", "匿名类实现接口; 不能有参数" }, { "compiler.err.anon.class.impl.intf.no.qual.for.new", "匿名类实现接口; 不能有限定符 - 对于新" }, { "compiler.err.anon.class.impl.intf.no.typeargs", "匿名类实现接口; 不能具有类型参数" }, { "compiler.err.array.and.receiver", "接收方参数不允许使用传统数组记号" }, { "compiler.err.array.and.varargs", "无法在{2}中同时声明{0}和{1}" }, { "compiler.err.array.dimension.missing", "缺少数组维" }, { "compiler.err.array.req.but.found", "需要数组, 但找到{0}" }, { "compiler.err.assert.as.identifier", "从发行版 1.4 开始, ''assert'' 是一个关键字, 但不能用作标识符\n(请使用 -source 1.3 或更低版本以将 ''assert'' 用作标识符)" }, { "compiler.err.attribute.value.must.be.constant", "元素值必须为常量表达式" }, { "compiler.err.bad.functional.intf.anno", "意外的 @FunctionalInterface 注释" }, { "compiler.err.bad.functional.intf.anno.1", "意外的 @FunctionalInterface 注释\n{0}" }, { "compiler.err.bad.initializer", "{0}的初始化程序错误" }, { "compiler.err.break.outside.switch.loop", "在 switch 或 loop 外部中断" }, { "compiler.err.call.must.be.first.stmt.in.ctor", "对{0}的调用必须是构造器中的第一个语句" }, { "compiler.err.call.to.super.not.allowed.in.enum.ctor", "在枚举构造器中不允许调用超类" }, { "compiler.err.cannot.create.array.with.diamond", "无法创建具有 ''<>'' 的数组" }, { "compiler.err.cannot.create.array.with.type.arguments", "无法创建具有类型变量的数组" }, { "compiler.err.cant.access", "无法访问{0}\n{1}" }, { "compiler.err.cant.apply.diamond", "无法推断{0}的类型参数" }, { "compiler.err.cant.apply.diamond.1", "无法推断{0}的类型参数\n原因: {1}" }, { "compiler.err.cant.apply.symbol", "无法将{4} {5}中的{0} {1}应用到给定类型;\n需要: {2}\n找到: {3}\n原因: {6}" }, { "compiler.err.cant.apply.symbols", "对于{1}({2}), 找不到合适的{0}" }, { "compiler.err.cant.assign.val.to.final.var", "无法为最终变量{0}分配值" }, { "compiler.err.cant.deref", "无法取消引用{0}" }, { "compiler.err.cant.extend.intf.annotation", "对于 @interfaces, 不允许 ''extends''" }, { "compiler.err.cant.inherit.diff.arg", "无法使用以下不同的参数继承{0}: <{1}> 和 <{2}>" }, { "compiler.err.cant.inherit.from.anon", "无法从匿名类继承" }, { "compiler.err.cant.inherit.from.final", "无法从最终{0}进行继承" }, { "compiler.err.cant.read.file", "无法读取: {0}" }, { "compiler.err.cant.ref.before.ctor.called", "无法在调用超类型构造器之前引用{0}" }, { "compiler.err.cant.ref.non.effectively.final.var", "从{1}引用的本地变量必须是最终变量或实际上的最终变量" }, { "compiler.err.cant.resolve", "找不到符号\n符号: {0} {1}" }, { "compiler.err.cant.resolve.args", "找不到符号\n符号: {0} {1}({3})" }, { "compiler.err.cant.resolve.args.params", "找不到符号\n符号: {0} <{2}>{1}({3})" }, { "compiler.err.cant.resolve.location", "找不到符号\n符号:   {0} {1}\n位置: {4}" }, { "compiler.err.cant.resolve.location.args", "找不到符号\n符号:   {0} {1}({3})\n位置: {4}" }, { "compiler.err.cant.resolve.location.args.params", "找不到符号\n符号:   {0} <{2}>{1}({3})\n位置: {4}" }, { "compiler.err.cant.select.static.class.from.param.type", "无法从参数化的类型中选择静态类" }, { "compiler.err.cant.type.annotate.scoping", "无法使用 type-use 注释 {0} 来注释确定作用域结构" }, { "compiler.err.cant.type.annotate.scoping.1", "无法使用 type-use 注释 {0} 来注释确定作用域结构" }, { "compiler.err.catch.without.try", "有 ''catch'', 但是没有 ''try''" }, { "compiler.err.clash.with.pkg.of.same.name", "{0} {1}与带有相同名称的程序包冲突" }, { "compiler.err.class.cant.write", "写入{0}时出错: {1}" }, { "compiler.err.class.not.allowed", "此处不允许使用类, 接口或枚举声明" }, { "compiler.err.class.public.should.be.in.file", "类{0}是公共的, 应在名为 {0}.java 的文件中声明" }, { "compiler.err.concrete.inheritance.conflict", "{1}中的方法{0}和{3}中的方法{2}是使用相同的签名继承的" }, { "compiler.err.const.expr.req", "需要常量表达式" }, { "compiler.err.cont.outside.loop", "continue 在 loop 外部" }, { "compiler.err.cyclic.annotation.element", "元素 {0} 的类型为循环" }, { "compiler.err.cyclic.inheritance", "涉及{0}的循环继承" }, { "compiler.err.dc.bad.entity", "HTML 实体错误" }, { "compiler.err.dc.bad.gt", "''>'' 的用法错误" }, { "compiler.err.dc.bad.inline.tag", "内嵌标记的用法不正确" }, { "compiler.err.dc.gt.expected", "需要 ''>''" }, { "compiler.err.dc.identifier.expected", "需要标识符" }, { "compiler.err.dc.malformed.html", "格式错误的 HTML" }, { "compiler.err.dc.missing.semicolon", "缺少分号" }, { "compiler.err.dc.no.content", "无内容" }, { "compiler.err.dc.no.tag.name", "'@' 后没有标记名" }, { "compiler.err.dc.ref.bad.parens", "引用中缺少 '')''" }, { "compiler.err.dc.ref.syntax.error", "引用中出现语法错误" }, { "compiler.err.dc.ref.unexpected.input", "意外的文本" }, { "compiler.err.dc.unexpected.content", "意外的内容" }, { "compiler.err.dc.unterminated.inline.tag", "未终止的内嵌标记" }, { "compiler.err.dc.unterminated.signature", "未终止的签名" }, { "compiler.err.dc.unterminated.string", "未终止的字符串" }, { "compiler.err.default.allowed.in.intf.annotation.member", "注释类型声明中仅允许默认值" }, { "compiler.err.default.methods.not.supported.in.source", "-source {0} 中不支持默认方法\n(请使用 -source 8 或更高版本以启用默认方法)" }, { "compiler.err.default.overrides.object.member", "{1} {2} 中的默认方法{0}覆盖了 java.lang.Object 的成员" }, { "compiler.err.diamond.not.supported.in.source", "-source {0} 中不支持 diamond 运算符\n(请使用 -source 7 或更高版本以启用 diamond 运算符)" }, { "compiler.err.does.not.override.abstract", "{0}不是抽象的, 并且未覆盖{2}中的抽象方法{1}" }, { "compiler.err.doesnt.exist", "程序包{0}不存在" }, { "compiler.err.dot.class.expected", "需要 ''.class''" }, { "compiler.err.duplicate.annotation.invalid.repeated", "注释{0}不是有效的可重复注释" }, { "compiler.err.duplicate.annotation.member.value", "注释@{1}中的元素 ''{0}'' 重复。" }, { "compiler.err.duplicate.annotation.missing.container", "{0} 不是可重复的注释类型" }, { "compiler.err.duplicate.case.label", "case 标签重复" }, { "compiler.err.duplicate.class", "类重复: {0}" }, { "compiler.err.duplicate.default.label", "default 标签重复" }, { "compiler.err.else.without.if", "有 ''if'', 但是没有 ''else''" }, { "compiler.err.empty.char.lit", "空字符文字" }, { "compiler.err.encl.class.required", "需要包含{0}的封闭实例" }, { "compiler.err.enum.annotation.must.be.enum.constant", "枚举注释值必须是枚举常量" }, { "compiler.err.enum.as.identifier", "从发行版 5 开始, ''enum'' 为关键字, 而不用作标识符\n(请使用 -source 1.4 或更低版本以将 ''enum'' 用作标识符)" }, { "compiler.err.enum.cant.be.instantiated", "无法实例化枚举类型" }, { "compiler.err.enum.label.must.be.unqualified.enum", "枚举 switch case 标签必须为枚举常量的非限定名称" }, { "compiler.err.enum.no.finalize", "枚举不能有 finalize 方法" }, { "compiler.err.enum.no.subclassing", "类无法直接扩展 java.lang.Enum" }, { "compiler.err.enum.types.not.extensible", "枚举类型不可继承" }, { "compiler.err.enums.must.be.static", "只有在静态上下文中才允许使用枚举声明" }, { "compiler.err.enums.not.supported.in.source", "-source {0} 中不支持枚举\n(请使用 -source 5 或更高版本以启用枚举)" }, { "compiler.err.error", "错误: " }, { "compiler.err.error.reading.file", "读取{0}时出错; {1}" }, { "compiler.err.except.already.caught", "已捕获到异常错误{0}" }, { "compiler.err.except.never.thrown.in.try", "在相应的 try 语句主体中不能抛出异常错误{0}" }, { "compiler.err.expected", "需要{0}" }, { "compiler.err.expected2", "需要{0}或{1}" }, { "compiler.err.expected3", "需要{0}, {1}或{2}" }, { "compiler.err.final.parameter.may.not.be.assigned", "不能分配最终参数{0}" }, { "compiler.err.finally.without.try", "有 ''finally'', 但是没有 ''try''" }, { "compiler.err.foreach.not.applicable.to.type", "for-each 不适用于表达式类型\n要求: {1}\n找到:    {0}" }, { "compiler.err.foreach.not.supported.in.source", "-source {0}中不支持增强型 for 循环\n(使用 -source 5 或更高版本以启用 for-each 循环)" }, { "compiler.err.fp.number.too.large", "浮点数过大" }, { "compiler.err.fp.number.too.small", "浮点数过小" }, { "compiler.err.generic.array.creation", "创建泛型数组" }, { "compiler.err.generic.throwable", "泛型类不能扩展 java.lang.Throwable" }, { "compiler.err.generics.not.supported.in.source", "-source {0} 中不支持泛型\n(请使用 -source 5 或更高版本以启用泛型)" }, { "compiler.err.icls.cant.have.static.decl", "内部类{0}中的静态声明非法\n修饰符 ''static'' 仅允许在常量变量声明中使用" }, { "compiler.err.illegal.char", "非法字符: ''{0}''" }, { "compiler.err.illegal.char.for.encoding", "编码{0}的不可映射字符" }, { "compiler.err.illegal.combination.of.modifiers", "非法的修饰符组合: {0}和{1}" }, { "compiler.err.illegal.default.super.call", "默认超级调用中的类型限定符{0}错误\n{1}" }, { "compiler.err.illegal.dot", "非法 ''.''" }, { "compiler.err.illegal.enum.static.ref", "初始化程序中对静态字段的引用不合法" }, { "compiler.err.illegal.esc.char", "非法转义符" }, { "compiler.err.illegal.forward.ref", "非法前向引用" }, { "compiler.err.illegal.generic.type.for.instof", "instanceof 的泛型类型不合法" }, { "compiler.err.illegal.initializer.for.type", "{0}的初始化程序不合法" }, { "compiler.err.illegal.line.end.in.char.lit", "字符文字的行结尾不合法" }, { "compiler.err.illegal.nonascii.digit", "非法的非 ASCII 数字" }, { "compiler.err.illegal.qual.not.icls", "非法限定符; {0}不是内部类" }, { "compiler.err.illegal.self.ref", "初始化程序中存在自引用" }, { "compiler.err.illegal.start.of.expr", "非法的表达式开始" }, { "compiler.err.illegal.start.of.stmt", "非法的语句开始" }, { "compiler.err.illegal.start.of.type", "非法的类型开始" }, { "compiler.err.illegal.static.intf.meth.call", "静态接口方法调用非法\n应将接收方表达式替换为类型限定符 ''{0}''" }, { "compiler.err.illegal.underscore", "非法下划线" }, { "compiler.err.illegal.unicode.esc", "非法的 Unicode 转义" }, { "compiler.err.import.requires.canonical", "导入需要{0}的规范名称" }, { "compiler.err.improperly.formed.type.inner.raw.param", "类型的格式不正确, 给出了原始类型的类型参数" }, { "compiler.err.improperly.formed.type.param.missing", "类型的格式不正确, 缺少某些参数" }, { "compiler.err.incomparable.types", "不可比较的类型: {0}和{1}" }, { "compiler.err.incompatible.thrown.types.in.mref", "方法引用中抛出的类型{0}不兼容" }, { "compiler.err.incorrect.constructor.receiver.name", "接收方名称与外部封闭类类型不匹配\n需要: {0}\n找到: {1}" }, { "compiler.err.incorrect.constructor.receiver.type", "接收方类型与外部封闭类类型不匹配\n需要: {0}\n找到: {1}" }, { "compiler.err.incorrect.receiver.name", "接收方名称与封闭类类型不匹配\n需要: {0}\n找到: {1}" }, { "compiler.err.incorrect.receiver.type", "接收方类型与封闭类类型不匹配\n需要: {0}\n找到: {1}" }, { "compiler.err.initializer.must.be.able.to.complete.normally", "初始化程序必须能够正常完成" }, { "compiler.err.int.number.too.large", "过大的整数: {0}" }, { "compiler.err.intersection.types.in.cast.not.supported.in.source", "-source {0} 中不支持转换中的交叉类型\n(请使用 -source 8 或更高版本以启用默认方法)" }, { "compiler.err.intf.annotation.cant.have.type.params", "注释类型 {0} 不能为泛型" }, { "compiler.err.intf.annotation.member.clash", "注释类型{1}声明与方法 {0} 同名的元素" }, { "compiler.err.intf.annotation.members.cant.have.params", "注释类型声明中的元素无法声明形参" }, { "compiler.err.intf.annotation.members.cant.have.type.params", "注释类型声明中的元素不能为泛型方法" }, { "compiler.err.intf.expected.here", "此处需要接口" }, { "compiler.err.intf.meth.cant.have.body", "接口抽象方法不能带有主体" }, { "compiler.err.intf.not.allowed.here", "此处不允许使用接口" }, { "compiler.err.invalid.annotation.member.type", "注释类型元素 {0} 的类型无效" }, { "compiler.err.invalid.binary.number", "二进制数字中必须包含至少一个二进制数" }, { "compiler.err.invalid.hex.number", "十六进制数字必须包含至少一位十六进制数" }, { "compiler.err.invalid.meth.decl.ret.type.req", "方法声明无效; 需要返回类型" }, { "compiler.err.invalid.mref", "{0}引用无效\n{1}" }, { "compiler.err.invalid.repeatable.annotation", "注释重复: 使用无效的 @Repeatable 注释对{0}进行了注释" }, { "compiler.err.invalid.repeatable.annotation.elem.nondefault", "对于元素 {1}, 包含注释类型 ({0}) 没有默认值" }, { "compiler.err.invalid.repeatable.annotation.incompatible.target", "包含注释类型 ({0}) 适用的目标多于可重复注释类型 ({1})" }, { "compiler.err.invalid.repeatable.annotation.invalid.value", "{0}不是有效的 @Repeatable: 值元素无效" }, { "compiler.err.invalid.repeatable.annotation.multiple.values", "{0}不是有效的 @Repeatable, 已声明 {1} 个名为 ''value'' 的元素方法" }, { "compiler.err.invalid.repeatable.annotation.no.value", "{0}不是有效的 @Repeatable, 未声明任何值元素方法" }, { "compiler.err.invalid.repeatable.annotation.not.documented", "可重复注释类型 ({1}) 是 @Documented, 而包含注释类型 ({0}) 则不是" }, { "compiler.err.invalid.repeatable.annotation.not.inherited", "可重复注释类型 ({1}) 是 @Inherited, 而包含注释类型 ({0}) 则不是" }, { "compiler.err.invalid.repeatable.annotation.repeated.and.container.present", "容器 {0} 不得与其包含的元素同时存在" }, { "compiler.err.invalid.repeatable.annotation.retention", "包含注释类型 ({0}) 的保留期短于可重复注释类型 ({2}) 的保留期" }, { "compiler.err.invalid.repeatable.annotation.value.return", "包含注释类型 ({0}) 必须声明类型{2}的名为 ''value'' 的元素" }, { "compiler.err.io.exception", "读取源文件时出错: {0}" }, { "compiler.err.label.already.in.use", "标签{0}已使用" }, { "compiler.err.lambda.body.neither.value.nor.void.compatible", "lambda 主体不是值, 也不与 void 兼容" }, { "compiler.err.lambda.not.supported.in.source", "-source {0} 中不支持 lambda 表达式\n(请使用 -source 8 或更高版本以启用 lambda 表达式)" }, { "compiler.err.limit.code", "代码过长" }, { "compiler.err.limit.code.too.large.for.try.stmt", "try 语句的代码过长" }, { "compiler.err.limit.dimensions", "数组类型维过多" }, { "compiler.err.limit.locals", "本地变量过多" }, { "compiler.err.limit.parameters", "参数过多" }, { "compiler.err.limit.pool", "常量过多" }, { "compiler.err.limit.pool.in.class", "类{0}中的常量过多" }, { "compiler.err.limit.stack", "代码需要过多堆栈" }, { "compiler.err.limit.string", "常量字符串过长" }, { "compiler.err.limit.string.overflow", "对于常量池来说, 字符串 \"{0}...\" 的 UTF8 表示过长" }, { "compiler.err.local.enum", "枚举类型不能为本地类型" }, { "compiler.err.local.var.accessed.from.icls.needs.final", "从内部类中访问本地变量{0}; 需要被声明为最终类型" }, { "compiler.err.malformed.fp.lit", "浮点文字的格式错误" }, { "compiler.err.method.does.not.override.superclass", "方法不会覆盖或实现超类型的方法" }, { "compiler.err.method.invoked.with.incorrect.number.arguments", "使用不正确数量的参数调用了方法; 预期为 {0} 个, 找到 {1} 个" }, { "compiler.err.method.references.not.supported.in.source", "-source {0} 中不支持方法引用\n(请使用 -source 8 或更高版本以启用方法引用)" }, { "compiler.err.missing.meth.body.or.decl.abstract", "缺少方法主体, 或声明抽象" }, { "compiler.err.missing.ret.stmt", "缺少返回语句" }, { "compiler.err.mod.not.allowed.here", "此处不允许使用修饰符{0}" }, { "compiler.err.multicatch.not.supported.in.source", "-source {0} 中不支持 multi-catch 语句\n(请使用 -source 7 或更高版本以启用 multi-catch 语句)" }, { "compiler.err.multicatch.parameter.may.not.be.assigned", "可能未分配 multi-catch 参数{0}" }, { "compiler.err.multicatch.types.must.be.disjoint", "multi-catch 语句中的替代无法通过子类化关联\n替代{0}是替代{1}的子类" }, { "compiler.err.name.clash.same.erasure", "名称冲突: {0}和{1}具有相同疑符" }, { "compiler.err.name.clash.same.erasure.no.hide", "名称冲突: {1} 中的 {0} 和 {3} 中的 {2} 具有相同疑符, 但两者均不隐藏对方" }, { "compiler.err.name.clash.same.erasure.no.override", "名称冲突: {1}中的{0}和{3}中的{2}具有相同疑符, 但两者均不覆盖对方" }, { "compiler.err.name.clash.same.erasure.no.override.1", "名称冲突: {1} 中的 {0} 覆盖的方法的疑符与另一个方法的相同, 但两者均不覆盖对方\n第一个方法:  {3} 中的 {2}\n第二个方法: {5} 中的 {4}" }, { "compiler.err.name.reserved.for.internal.use", "{0}为内部使用保留" }, { "compiler.err.native.meth.cant.have.body", "本机方法不能带有主体" }, { "compiler.err.neither.conditional.subtype", "? 的不兼容类型: 两者都不是对方的子类型\n第二个操作数: {0}\n第三个操作数: {1}" }, { "compiler.err.new.not.allowed.in.annotation", "注释中不允许使用 ''new''" }, { "compiler.err.no.annotation.member", "{1}中没有注释成员{0}" }, { "compiler.err.no.annotations.on.dot.class", "类文字类型中不允许使用任何注释" }, { "compiler.err.no.encl.instance.of.type.in.scope", "作用域中没有类型为{0}的封闭实例" }, { "compiler.err.no.intf.expected.here", "此处不需要接口" }, { "compiler.err.no.match.entry", "{0}在{1}的条目中没有匹配项; 需要{2}" }, { "compiler.err.no.superclass", "{0}不具有超类。" }, { "compiler.err.non-static.cant.be.ref", "无法从静态上下文中引用非静态 {0} {1}" }, { "compiler.err.not.annotation.type", "{0}不是注释类型" }, { "compiler.err.not.def.access.class.intf.cant.access", "{1}中的{0}是在不可访问的类或接口中定义的" }, { "compiler.err.not.def.public.cant.access", "{0}在{1}中不是公共的; 无法从外部程序包中对其进行访问" }, { "compiler.err.not.encl.class", "不是封闭类: {0}" }, { "compiler.err.not.in.profile", "{0}在配置文件 ''{1}'' 中不可用" }, { "compiler.err.not.loop.label", "不是 loop 标签: {0}" }, { "compiler.err.not.stmt", "不是语句" }, { "compiler.err.not.within.bounds", "类型参数{0}不在类型变量{1}的范围内" }, { "compiler.err.operator.cant.be.applied", "一元运算符 ''{0}'' 的操作数类型{1}错误" }, { "compiler.err.operator.cant.be.applied.1", "二元运算符 ''{0}'' 的操作数类型错误\n第一个类型:  {1}\n第二个类型: {2}" }, { "compiler.err.orphaned", "孤立的{0}" }, { "compiler.err.override.incompatible.ret", "{0}\n返回类型{1}与{2}不兼容" }, { "compiler.err.override.meth", "{0}\n被覆盖的方法为{1}" }, { "compiler.err.override.meth.doesnt.throw", "{0}\n被覆盖的方法未抛出{1}" }, { "compiler.err.override.static", "{0}\n覆盖的方法为 static" }, { "compiler.err.override.weaker.access", "{0}\n正在尝试分配更低的访问权限; 以前为{1}" }, { "compiler.err.pkg.annotations.sb.in.package-info.java", "程序包注释应在文件 package-info.java 中" }, { "compiler.err.pkg.clashes.with.class.of.same.name", "程序包{0}与带有相同名称的类冲突" }, { "compiler.err.premature.eof", "解析时已到达文件结尾" }, { "compiler.err.prob.found.req", "不兼容的类型: {0}" }, { "compiler.err.proc.bad.config.file", "服务配置文件不正确, 或构造处理程序对象{0}时抛出异常错误" }, { "compiler.err.proc.cant.access", "无法访问{0}\n{1}\n有关详细信息, 请参阅以下堆栈跟踪。\n{2}" }, { "compiler.err.proc.cant.access.1", "无法访问{0}\n{1}" }, { "compiler.err.proc.cant.create.loader", "无法为注释处理程序{0}创建类加载器" }, { "compiler.err.proc.cant.find.class", "找不到 ''{0}'' 的类文件。" }, { "compiler.err.proc.messager", "{0}" }, { "compiler.err.proc.no.explicit.annotation.processing.requested", "仅当显式请求注释处理时才接受类名称 ''{0}''" }, { "compiler.err.proc.no.service", "ServiceLoader 不可用, 但它是注释处理所必需的。" }, { "compiler.err.proc.processor.bad.option.name", "处理程序 ''{1}'' 提供的选项名称 ''{0}'' 错误" }, { "compiler.err.proc.processor.cant.instantiate", "无法实例化处理程序 ''{0}'' 的实例" }, { "compiler.err.proc.processor.not.found", "找不到注释处理程序 ''{0}''" }, { "compiler.err.proc.processor.wrong.type", "注释处理程序 ''{0}'' 未实现 javax.annotation.processing.Processor" }, { "compiler.err.proc.service.problem", "创建服务加载器以加载处理程序时出错。" }, { "compiler.err.qualified.new.of.static.class", "限定的新静态类" }, { "compiler.err.receiver.parameter.not.applicable.constructor.toplevel.class", "接收方参数不适用于顶层类的构造器" }, { "compiler.err.recursive.ctor.invocation", "递归构造器调用" }, { "compiler.err.ref.ambiguous", "对{0}的引用不明确\n{3} 中的{1} {2} 和 {6} 中的{4} {5} 都匹配" }, { "compiler.err.repeatable.annotations.not.supported.in.source", "-source {0}中不支持重复注释\n(请使用 -source 8 或更高版本以启用重复注释)" }, { "compiler.err.repeated.annotation.target", "注释目标重复" }, { "compiler.err.repeated.interface", "接口重复" }, { "compiler.err.repeated.modifier", "修饰符重复" }, { "compiler.err.report.access", "{0} 在 {2} 中是 {1} 访问控制" }, { "compiler.err.ret.outside.meth", "返回外部方法" }, { "compiler.err.signature.doesnt.match.intf", "签名与{0}不匹配; 不兼容的接口" }, { "compiler.err.signature.doesnt.match.supertype", "签名与{0}不匹配; 不兼容的超类型" }, { "compiler.err.source.cant.overwrite.input.file", "写入源时出错; 无法覆盖输入文件{0}" }, { "compiler.err.stack.sim.error", "内部错误: {0}中的堆栈 sim 错误" }, { "compiler.err.static.imp.only.classes.and.interfaces", "仅从类和接口静态导入" }, { "compiler.err.static.import.not.supported.in.source", "-source {0} 中不支持静态导入声明\n(请使用 -source 5 或更高版本以启用静态导入声明)" }, { "compiler.err.static.intf.method.invoke.not.supported.in.source", "-source {0} 中不支持静态接口方法调用\n(请使用 -source 8 或更高版本以启用静态接口方法调用)" }, { "compiler.err.static.intf.methods.not.supported.in.source", "-source {0} 中不支持静态接口方法\n(请使用 -source 8 或更高版本以启用静态接口方法)" }, { "compiler.err.string.const.req", "需要常量字符串表达式" }, { "compiler.err.string.switch.not.supported.in.source", "-source {0} 中不支持 switch 中存在字符串\n(请使用 -source 7 或更高版本以允许 switch 中存在字符串)" }, { "compiler.err.synthetic.name.conflict", "符号{0}与{1}中的 compiler-synthesized 符号冲突" }, { "compiler.err.this.as.identifier", "从发行版 8 开始, ''this'' 只能作为接收方类型的参数名, 该参数必须为第一个参数" }, { "compiler.err.throws.not.allowed.in.intf.annotation", "@interface 成员中不允许使用 throws 子句" }, { "compiler.err.try.resource.may.not.be.assigned", "可能未分配可自动关闭的资源{0}" }, { "compiler.err.try.with.resources.not.supported.in.source", "-source {0} 中不支持 try-with-resources\n(请使用 -source 7 或更高版本以启用 try-with-resources)" }, { "compiler.err.try.without.catch.finally.or.resource.decls", "''try'' 不带有 ''catch'', ''finally'' 或资源声明" }, { "compiler.err.try.without.catch.or.finally", "有 ''try'', 但是没有 ''catch'' 或 ''finally''" }, { "compiler.err.type.annotations.not.supported.in.source", "-source {0} 中不支持类型注释\n(请使用 -source 8 或更高版本以启用类型注释)" }, { "compiler.err.type.doesnt.take.params", "类型{0}不带有参数" }, { "compiler.err.type.found.req", "意外的类型\n需要: {1}\n找到:    {0}" }, { "compiler.err.type.var.cant.be.deref", "无法从类型变量中进行选择" }, { "compiler.err.type.var.may.not.be.followed.by.other.bounds", "类型变量后面不能带有其他限制范围" }, { "compiler.err.type.var.more.than.once", "类型变量{0}在{1}的结果类型中多次出现; 必须对其进行实例化" }, { "compiler.err.type.var.more.than.once.in.result", "类型变量{0}在{1}的类型中多次出现; 必须对其进行实例化" }, { "compiler.err.types.incompatible.abstract.default", "{0} {1}从类型 {4} 和 {5} 中继承了{2}({3}) 的抽象和默认值" }, { "compiler.err.types.incompatible.diff.ret", "类型{0}和{1}不兼容; 两者都定义了{2}, 但却带有不相关的返回类型" }, { "compiler.err.types.incompatible.unrelated.defaults", "{0} {1}从类型 {4} 和 {5} 中继承了{2}({3}) 的不相关默认值" }, { "compiler.err.unclosed.char.lit", "未结束的字符文字" }, { "compiler.err.unclosed.comment", "未结束的注释" }, { "compiler.err.unclosed.str.lit", "未结束的字符串文字" }, { "compiler.err.undef.label", "未定义的标签: {0}" }, { "compiler.err.underscore.as.identifier.in.lambda", "''_'' 用作标识符\n(对于 lambda 参数, 禁止将 ''_'' 用作标识符)" }, { "compiler.err.unexpected.lambda", "此处不应为 lambda 表达式" }, { "compiler.err.unexpected.mref", "此处不应为方法引用" }, { "compiler.err.unexpected.type", "意外的类型\n需要: {0}\n找到:    {1}" }, { "compiler.err.unreachable.stmt", "无法访问的语句" }, { "compiler.err.unreported.exception.default.constructor", "默认构造器中未报告的异常错误{0}" }, { "compiler.err.unreported.exception.implicit.close", "未报告的异常错误{0}; 必须对其进行捕获或声明以便抛出\n对资源变量 ''{1}'' 隐式调用 close() 时抛出了异常错误" }, { "compiler.err.unreported.exception.need.to.catch.or.throw", "未报告的异常错误{0}; 必须对其进行捕获或声明以便抛出" }, { "compiler.err.unsupported.binary.lit", "-source {0} 中不支持二进制文字\n(请使用 -source 7 或更高版本以启用二进制文字)" }, { "compiler.err.unsupported.cross.fp.lit", "该 VM 不支持十六进制浮点文字" }, { "compiler.err.unsupported.encoding", "不支持的编码: {0}" }, { "compiler.err.unsupported.fp.lit", "-source {0} 中不支持十六进制浮点文字\n(请使用 -source 5 或更高版本以启用十六进制浮点文字)" }, { "compiler.err.unsupported.underscore.lit", "-source {0} 中不支持文字中存在下划线\n(请使用 -source 7 或更高版本以允许文字中存在下划线)" }, { "compiler.err.var.might.already.be.assigned", "可能已分配变量{0}" }, { "compiler.err.var.might.be.assigned.in.loop", "可能在 loop 中分配了变量{0}" }, { "compiler.err.var.might.not.have.been.initialized", "可能尚未初始化变量{0}" }, { "compiler.err.var.not.initialized.in.default.constructor", "变量 {0} 未在默认构造器中初始化" }, { "compiler.err.varargs.and.old.array.syntax", "variable-arity 参数中不允许使用传统数组记号" }, { "compiler.err.varargs.and.receiver", "接收方参数不允许使用 varargs 记号" }, { "compiler.err.varargs.invalid.trustme.anno", "{0} 注释无效。{1}" }, { "compiler.err.varargs.not.supported.in.source", "-source {0} 中不支持 variable-arity 方法\n(请使用 -source 5 或更高版本以启用 variable-arity 方法)" }, { "compiler.err.variable.not.allowed", "此处不允许使用变量声明" }, { "compiler.err.void.not.allowed.here", "此处不允许使用 ''空'' 类型" }, { "compiler.err.warnings.and.werror", "发现警告, 但指定了 -Werror" }, { "compiler.err.wrong.number.type.args", "类型变量数目错误; 需要{0}" }, { "compiler.misc.anonymous.class", "<匿名{0}>" }, { "compiler.misc.applicable.method.found", "找到第 {0} 个适用方法: {1}" }, { "compiler.misc.applicable.method.found.1", "找到第 {0} 个适用方法: {1}\n({2})" }, { "compiler.misc.arg.length.mismatch", "实际参数列表和形式参数列表长度不同" }, { "compiler.misc.bad.class.file.header", "错误的类文件: {0}\n{1}\n请删除该文件或确保该文件位于正确的类路径子目录中。" }, { "compiler.misc.bad.class.signature", "错误的类签名: {0}" }, { "compiler.misc.bad.const.pool.entry", "{0} 中错误的常量池条目\n预期为索引 {2} 处的 {1}" }, { "compiler.misc.bad.const.pool.tag", "错误的常量池标记: {0}" }, { "compiler.misc.bad.const.pool.tag.at", "错误的常量池标记: {0}, 位于{1}" }, { "compiler.misc.bad.enclosing.class", "{0}的封闭类错误: {1}" }, { "compiler.misc.bad.enclosing.method", "类 {0} 的封闭方法属性错误" }, { "compiler.misc.bad.intersection.target.for.functional.expr", "lambda 或方法引用的交叉类型目标错误\n{0}" }, { "compiler.misc.bad.runtime.invisible.param.annotations", "错误的 RuntimeInvisibleParameterAnnotations 属性: {0}" }, { "compiler.misc.bad.signature", "错误的签名: {0}" }, { "compiler.misc.bad.source.file.header", "错误的源文件: {0}\n{1}\n请删除该文件或确保该文件位于正确的源路径子目录中。" }, { "compiler.misc.bad.type.annotation.value", "错误的类型注释目标类型值: {0}" }, { "compiler.misc.base.membership", "您的所有基类都属于我们" }, { "compiler.misc.cant.access.inner.cls.constr", "无法访问构造器 {0}({1})\n作用域中没有类型为{2}的封闭实例" }, { "compiler.misc.cant.apply.diamond.1", "无法推断{0}的类型参数\n原因: {1}" }, { "compiler.misc.cant.apply.symbol", "无法将 {4} {5}中的 {0} {1}应用到给定类型\n需要: {2}\n找到: {3}\n原因: {6}" }, { "compiler.misc.cant.apply.symbols", "对于{1}({2}), 找不到合适的{0}" }, { "compiler.misc.cant.implement", "{1}中的{0}无法实现{3}中的{2}" }, { "compiler.misc.cant.override", "{1}中的{0}无法覆盖{3}中的{2}" }, { "compiler.misc.cant.resolve.location.args", "找不到符号\n符号:   {0} {1}({3})\n位置: {4}" }, { "compiler.misc.cant.resolve.location.args.params", "找不到符号\n符号:   {0} <{2}>{1}({3})\n位置: {4}" }, { "compiler.misc.captured.type", "CAP#{0}" }, { "compiler.misc.ccf.found.later.version", "类文件的版本高于预期: {0}" }, { "compiler.misc.ccf.unrecognized.attribute", "无法识别的属性: {0}" }, { "compiler.misc.clashes.with", "{1}中的{0}与{3}中的{2}冲突" }, { "compiler.misc.class.file.not.found", "找不到{0}的类文件" }, { "compiler.misc.class.file.wrong.class", "类文件包含错误的类: {0}" }, { "compiler.misc.conditional.target.cant.be.void", "条件表达式的目标类型不能为空" }, { "compiler.misc.count.error", "{0} 个错误" }, { "compiler.misc.count.error.plural", "{0} 个错误" }, { "compiler.misc.count.warn", "{0} 个警告" }, { "compiler.misc.count.warn.plural", "{0} 个警告" }, { "compiler.misc.descriptor", "描述符: {2} {0}({1})" }, { "compiler.misc.descriptor.throws", "描述符: {2} {0}({1}) 抛出{3}" }, { "compiler.misc.diamond", "{0}<>" }, { "compiler.misc.diamond.and.anon.class", "无法将 ''<>'' 与匿名内部类一起使用" }, { "compiler.misc.diamond.and.explicit.params", "不能将 ''<>'' 与构造器的显式类型参数一起使用" }, { "compiler.misc.diamond.non.generic", "无法将 ''<>'' 与非泛型类{0}一起使用" }, { "compiler.misc.explicit.param.do.not.conform.to.bounds", "显式类型参数{0}不符合声明的范围{1}" }, { "compiler.misc.fatal.err.cant.close", "致命错误: 无法关闭编译器资源" }, { "compiler.misc.fatal.err.cant.locate.ctor", "致命错误: 找不到{0}的构造器" }, { "compiler.misc.fatal.err.cant.locate.field", "致命错误: 找不到字段{0}" }, { "compiler.misc.fatal.err.cant.locate.meth", "致命错误: 找不到方法{0}" }, { "compiler.misc.fatal.err.no.java.lang", "致命错误: 在类路径或引导类路径中找不到程序包 java.lang" }, { "compiler.misc.file.does.not.contain.package", "文件不包含程序包{0}" }, { "compiler.misc.file.doesnt.contain.class", "文件不包含类{0}" }, { "compiler.misc.illegal.start.of.class.file", "非法的类文件开始" }, { "compiler.misc.inaccessible.varargs.type", "形式 varargs 元素类型{0}无法从 {1} {2} 进行访问" }, { "compiler.misc.inapplicable.method", "{0} {1}.{2}不适用\n({3})" }, { "compiler.misc.incompatible.abstracts", "在 {0} {1} 中找到多个非覆盖抽象方法" }, { "compiler.misc.incompatible.arg.types.in.lambda", "lambda 表达式中的参数类型不兼容" }, { "compiler.misc.incompatible.arg.types.in.mref", "方法引用中的参数类型不兼容" }, { "compiler.misc.incompatible.descs.in.functional.intf", "在 {0} {1} 中找到不兼容的函数描述符" }, { "compiler.misc.incompatible.eq.lower.bounds", "推论变量{0}具有不兼容的限制范围\n等式约束条件: {1}\n下限: {2}" }, { "compiler.misc.incompatible.eq.upper.bounds", "推论变量 {0} 具有不兼容的限制范围\n等式约束条件: {1}\n上限: {2}" }, { "compiler.misc.incompatible.ret.type.in.lambda", "lambda 表达式中的返回类型错误\n{0}" }, { "compiler.misc.incompatible.ret.type.in.mref", "方法引用中的返回类型错误\n{0}" }, { "compiler.misc.incompatible.type.in.conditional", "条件表达式中的类型错误\n{0}" }, { "compiler.misc.incompatible.upper.bounds", "推论变量 {0} 具有不兼容的上限 {1}" }, { "compiler.misc.inconvertible.types", "{0}无法转换为{1}" }, { "compiler.misc.infer.arg.length.mismatch", "无法推断类型变量 {0}\n(实际参数列表和形式参数列表长度不同)" }, { "compiler.misc.infer.no.conforming.assignment.exists", "无法推断类型变量 {0}\n(参数不匹配; {1})" }, { "compiler.misc.infer.no.conforming.instance.exists", "不存在类型变量{0}的实例, 以使{1}与{2}一致" }, { "compiler.misc.infer.varargs.argument.mismatch", "无法推断类型变量 {0}\n(varargs 不匹配; {1})" }, { "compiler.misc.inferred.do.not.conform.to.eq.bounds", "推断类型不符合等式约束条件\n推断: {0}\n等式约束条件: {1}" }, { "compiler.misc.inferred.do.not.conform.to.lower.bounds", "推断类型不符合下限\n推断: {0}\n下限: {1}" }, { "compiler.misc.inferred.do.not.conform.to.upper.bounds", "推断类型不符合上限\n推断: {0}\n上限: {1}" }, { "compiler.misc.inner.cls", "内部类" }, { "compiler.misc.intersection.type", "INT#{0}" }, { "compiler.misc.invalid.default.interface", "在 {0}.{1} 版类文件中找到默认方法" }, { "compiler.misc.invalid.generic.lambda.target", "lambda 表达式的函数描述符无效\n{1} {2} 中的方法 {0} 为泛型方法" }, { "compiler.misc.invalid.mref", "{0}引用无效\n{1}" }, { "compiler.misc.invalid.static.interface", "在 {0}.{1} 版类文件中找到静态方法" }, { "compiler.misc.kindname.annotation", "@interface" }, { "compiler.misc.kindname.class", "类" }, { "compiler.misc.kindname.constructor", "构造器" }, { "compiler.misc.kindname.enum", "枚举" }, { "compiler.misc.kindname.instance.init", "实例初始化程序" }, { "compiler.misc.kindname.interface", "接口" }, { "compiler.misc.kindname.method", "方法" }, { "compiler.misc.kindname.package", "程序包" }, { "compiler.misc.kindname.static", "静态" }, { "compiler.misc.kindname.static.init", "静态初始化程序" }, { "compiler.misc.kindname.type.variable", "类型变量" }, { "compiler.misc.kindname.type.variable.bound", "类型变量的限制范围" }, { "compiler.misc.kindname.value", "值" }, { "compiler.misc.kindname.variable", "变量" }, { "compiler.misc.lambda", "lambda 表达式" }, { "compiler.misc.location", "{0} {1}" }, { "compiler.misc.location.1", "类型为{2}的{0} {1}" }, { "compiler.misc.missing.ret.val", "缺少返回值" }, { "compiler.misc.mref.infer.and.explicit.params", "不能将原始构造器引用与构造器的显式类型参数一起使用" }, { "compiler.misc.no.abstracts", "在 {0} {1} 中找不到抽象方法" }, { "compiler.misc.no.args", "没有参数" }, { "compiler.misc.no.conforming.assignment.exists", "参数不匹配; {0}" }, { "compiler.misc.no.suitable.functional.intf.inst", "无法推断{0}的函数接口描述符" }, { "compiler.misc.no.unique.maximal.instance.exists", "对于上限为{1}的类型变量{0}, 不存在唯一最大实例" }, { "compiler.misc.no.unique.minimal.instance.exists", "对于下限为{1}的类型变量{0}, 不存在唯一最小实例" }, { "compiler.misc.non-static.cant.be.ref", "无法从静态上下文中引用非静态 {0} {1}" }, { "compiler.misc.not.a.functional.intf", "{0} 不是函数接口" }, { "compiler.misc.not.a.functional.intf.1", "{0} 不是函数接口\n{1}" }, { "compiler.misc.not.an.intf.component", "组件类型{0}不是接口" }, { "compiler.misc.not.applicable.method.found", "找到第 {0} 个不适用的方法: {1}\n({2})" }, { "compiler.misc.not.def.access.class.intf.cant.access", "{1}中的{0}是在不可访问的类或接口中定义的" }, { "compiler.misc.not.def.public.cant.access", "{0}在{1}中不是公共的; 无法从外部程序包中对其进行访问" }, { "compiler.misc.overridden.default", "覆盖了{1}中的方法 {0}" }, { "compiler.misc.partial.inst.sig", "部分实例化为: {0}" }, { "compiler.misc.possible.loss.of.precision", "从{0}转换到{1}可能会有损失" }, { "compiler.misc.prob.found.req", "不兼容的类型: {0}" }, { "compiler.misc.redundant.supertype", "冗余接口 {0} 已由 {1} 扩展" }, { "compiler.misc.ref.ambiguous", "对{0}的引用不明确\n{3} 中的{1} {2} 和 {6} 中的{4} {5} 都匹配" }, { "compiler.misc.report.access", "{0} 在 {2} 中是 {1} 访问控制" }, { "compiler.misc.resume.abort", "继续(R), 放弃(A)>" }, { "compiler.misc.source.unavailable", "(源不可用)" }, { "compiler.misc.static.bound.mref", "静态限制范围方法引用" }, { "compiler.misc.static.method.in.unbound.lookup", "在未绑定查找中找到静态{0} {1}" }, { "compiler.misc.static.mref.with.targs", "有关静态方法引用的参数化限定符" }, { "compiler.misc.token.bad-symbol", "<错误符号>" }, { "compiler.misc.token.character", "<字符>" }, { "compiler.misc.token.double", "<双精度型>" }, { "compiler.misc.token.end-of-input", "<输入结束>" }, { "compiler.misc.token.float", "<浮点型>" }, { "compiler.misc.token.identifier", "<标识符>" }, { "compiler.misc.token.integer", "<整型>" }, { "compiler.misc.token.long-integer", "<长整型>" }, { "compiler.misc.token.string", "<字符串>" }, { "compiler.misc.try.not.applicable.to.type", "try-with-resources 不适用于变量类型\n({0})" }, { "compiler.misc.type.captureof", "capture#{0}, 共 {1}" }, { "compiler.misc.type.captureof.1", "capture#{0}" }, { "compiler.misc.type.none", "<无>" }, { "compiler.misc.type.null", "<空值>" }, { "compiler.misc.type.parameter", "类型参数{0}" }, { "compiler.misc.type.req.array.or.iterable", "数组或 java.lang.Iterable" }, { "compiler.misc.type.req.class", "类" }, { "compiler.misc.type.req.class.array", "类或数组" }, { "compiler.misc.type.req.exact", "不带限制范围的类或接口" }, { "compiler.misc.type.req.ref", "引用" }, { "compiler.misc.type.var", "{0}#{1}" }, { "compiler.misc.unable.to.access.file", "无法访问文件: {0}" }, { "compiler.misc.unchecked.assign", "未经检查的转换" }, { "compiler.misc.unchecked.cast.to.type", "未经检查的转换" }, { "compiler.misc.unchecked.clash.with", "{1}中的{0}覆盖了{3}中的{2}" }, { "compiler.misc.unchecked.implement", "{1}中的{0}实现了{3}中的{2}" }, { "compiler.misc.unchecked.override", "{1}中的{0}覆盖了{3}中的{2}" }, { "compiler.misc.undecl.type.var", "未声明的类型变量: {0}" }, { "compiler.misc.unexpected.ret.val", "意外的返回值" }, { "compiler.misc.unicode.str.not.supported", "不支持类文件中的 Unicode 字符串" }, { "compiler.misc.unnamed.package", "未命名程序包" }, { "compiler.misc.varargs.argument.mismatch", "varargs 不匹配; {0}" }, { "compiler.misc.varargs.clash.with", "{1}中的{0}覆盖了{3}中的{2}" }, { "compiler.misc.varargs.implement", "{1}中的{0}实现了{3}中的{2}" }, { "compiler.misc.varargs.override", "{1}中的{0}覆盖了{3}中的{2}" }, { "compiler.misc.varargs.trustme.on.non.varargs.meth", "方法 {0} 不是 varargs 方法。" }, { "compiler.misc.varargs.trustme.on.reifiable.varargs", "Varargs 元素类型{0}可具体化。" }, { "compiler.misc.varargs.trustme.on.virtual.varargs", "实例方法 {0} 不是最终的。" }, { "compiler.misc.verbose.checking.attribution", "[正在检查{0}]" }, { "compiler.misc.verbose.classpath", "[类文件的搜索路径: {0}]" }, { "compiler.misc.verbose.loading", "[正在加载{0}]" }, { "compiler.misc.verbose.parsing.done", "[解析已完成, 用时 {0} 毫秒]" }, { "compiler.misc.verbose.parsing.started", "[解析开始时间 {0}]" }, { "compiler.misc.verbose.retro", "[正在更新{0}]" }, { "compiler.misc.verbose.retro.with", "\t正在使用{1}更新{0}" }, { "compiler.misc.verbose.retro.with.list", "\t正在使用类型参数{1}, 超类型{2}和接口{3}更新{0}" }, { "compiler.misc.verbose.sourcepath", "[源文件的搜索路径: {0}]" }, { "compiler.misc.verbose.total", "[共 {0} 毫秒]" }, { "compiler.misc.verbose.wrote.file", "[已写入{0}]" }, { "compiler.misc.version.not.available", "(版本信息不可用)" }, { "compiler.misc.where.captured", "{0}从{3}的捕获扩展{1} 超 {2}" }, { "compiler.misc.where.captured.1", "{0}从{3}的捕获扩展{1}" }, { "compiler.misc.where.description.captured", "其中, {0}是新类型变量:" }, { "compiler.misc.where.description.captured.1", "其中, {0}是新类型变量:" }, { "compiler.misc.where.description.intersection", "其中, {0}是交叉类型:" }, { "compiler.misc.where.description.intersection.1", "其中, {0}是交叉类型:" }, { "compiler.misc.where.description.typevar", "其中, {0}是类型变量:" }, { "compiler.misc.where.description.typevar.1", "其中, {0}是类型变量:" }, { "compiler.misc.where.fresh.typevar", "{0}扩展{1}" }, { "compiler.misc.where.intersection", "{0}扩展{1}" }, { "compiler.misc.where.typevar", "{0}扩展已在{2} {3}中声明的{1}" }, { "compiler.misc.where.typevar.1", "{0}已在{2} {3}中声明" }, { "compiler.misc.wrong.version", "类文件具有错误的版本 {0}.{1}, 应为 {2}.{3}" }, { "compiler.misc.x.print.processor.info", "处理程序{0}与{1}匹配并返回{2}。" }, { "compiler.misc.x.print.rounds", "循环 {0}:\n\t输入文件: {1}\n\t注释: {2}\n\t最后一个循环: {3}" }, { "compiler.note.compressed.diags", "某些消息已经过简化; 请使用 -Xdiags:verbose 重新编译以获得完整输出" }, { "compiler.note.deferred.method.inst", "方法 {0} 的延迟实例化\n实例化签名: {1}\n目标类型: {2}" }, { "compiler.note.deprecated.filename", "{0}使用或覆盖了已过时的 API。" }, { "compiler.note.deprecated.filename.additional", "{0}还使用或覆盖了已过时的 API。" }, { "compiler.note.deprecated.plural", "某些输入文件使用或覆盖了已过时的 API。" }, { "compiler.note.deprecated.plural.additional", "某些输入文件还使用或覆盖了已过时的 API。" }, { "compiler.note.deprecated.recompile", "有关详细信息, 请使用 -Xlint:deprecation 重新编译。" }, { "compiler.note.lambda.stat", "转换 lambda 表达式\n替代 metafactory = {0}\n合成方法 = {1}" }, { "compiler.note.mref.stat", "转换方法引用\n替代 metafactory = {0}\n" }, { "compiler.note.mref.stat.1", "转换方法引用\n替代 metafactory = {0}\nbridge 方法 = {1}" }, { "compiler.note.note", "注: " }, { "compiler.note.potential.lambda.found", "可将此匿名内部类创建转换为 lambda 表达式。" }, { "compiler.note.proc.messager", "{0}" }, { "compiler.note.sunapi.filename", "{0}使用了可能会在未来发行版中删除的内部专用 API。" }, { "compiler.note.sunapi.filename.additional", "{0}使用了可能会在未来发行版中删除的其他内部专用 API。" }, { "compiler.note.sunapi.plural", "某些输入文件使用了可能会在未来发行版中删除的内部专用 API。" }, { "compiler.note.sunapi.plural.additional", "某些输入文件使用了可能会在未来发行版中删除的其他内部专用 API。" }, { "compiler.note.sunapi.recompile", "有关详细信息, 请使用 -Xlint:sunapi 重新编译。" }, { "compiler.note.unchecked.filename", "{0}使用了未经检查或不安全的操作。" }, { "compiler.note.unchecked.filename.additional", "{0}还有未经检查或不安全的操作。" }, { "compiler.note.unchecked.plural", "某些输入文件使用了未经检查或不安全的操作。" }, { "compiler.note.unchecked.plural.additional", "某些输入文件还使用了未经检查或不安全的操作。" }, { "compiler.note.unchecked.recompile", "有关详细信息, 请使用 -Xlint:unchecked 重新编译。" }, { "compiler.note.verbose.resolve.multi", "将类型 {1} 的方法 {0} 解析为候选项 {2}\n阶段: {3}\n具有实际值: {4}\n具有类型参数: {5}\n候选项:" }, { "compiler.note.verbose.resolve.multi.1", "类型 {1} 的方法 {0} 解析错误\n阶段: {3}\n具有实际值: {4}\n具有类型参数: {5}\n候选项:" }, { "compiler.warn.access.to.sensitive.member.from.serializable.element", "可串行化元素对敏感成员 {0} 的访问可以由不受信任的代码公开执行" }, { "compiler.warn.annotation.method.not.found", "无法找到类型 ''{0}'' 的注释方法 ''{1}()''" }, { "compiler.warn.annotation.method.not.found.reason", "无法找到类型 ''{0}'' 的注释方法 ''{1}()'': {2}" }, { "compiler.warn.assert.as.identifier", "从发行版 1.4 开始, ''assert'' 是一个关键字, 但不能用作标识符\n(请使用 -source 1.4 或更高版本以将 ''assert'' 用作关键字)" }, { "compiler.warn.auxiliary.class.accessed.from.outside.of.its.source.file", "{1} 中的辅助类{0}不应从其自身的源文件以外访问" }, { "compiler.warn.big.major.version", "{0}: 主版本 {1} 比 {2} 新, 此编译器支持最新的主版本。\n建议升级此编译器。" }, { "compiler.warn.constant.SVUID", "serialVersionUID 在类{0}中必须是常量" }, { "compiler.warn.diamond.redundant.args", "新表达式中存在冗余类型参数 (改用 diamond 运算符)。" }, { "compiler.warn.diamond.redundant.args.1", "新表达式中存在冗余类型参数 (改用 diamond 运算符)。\n显式: {0}\n推断: {1}" }, { "compiler.warn.dir.path.element.not.found", "错误的路径元素 \"{0}\": 没有这种目录" }, { "compiler.warn.div.zero", "除数为零" }, { "compiler.warn.empty.if", "if 之后没有语句" }, { "compiler.warn.enum.as.identifier", "从发行版 5 开始, ''enum'' 为关键字, 而不用作标识符\n(请使用 -source 5 或更高版本以将 ''enum'' 用作关键字)" }, { "compiler.warn.finally.cannot.complete", "finally 子句无法正常完成" }, { "compiler.warn.forward.ref", "先引用变量 ''{0}'', 然后再对其初始化" }, { "compiler.warn.future.attr", "{1}.{2} 版类文件中引入的 {0} 属性在 {3}.{4} 版类文件中被忽略" }, { "compiler.warn.has.been.deprecated", "{1}中的{0}已过时" }, { "compiler.warn.illegal.char.for.encoding", "编码{0}的不可映射字符" }, { "compiler.warn.improper.SVUID", "必须在类{0}中将 serialVersionUID 声明为 static final" }, { "compiler.warn.inexact.non-varargs.call", "最后一个参数使用了不准确的变量类型的 varargs 方法的非 varargs 调用; \n对于 varargs 调用, 应使用 {0}\n对于非 varargs 调用, 应使用 {1}, 这样也可以抑制此警告" }, { "compiler.warn.invalid.archive.file", "以下路径中存在意外的文件: {0}" }, { "compiler.warn.lintOption", "[{0}] " }, { "compiler.warn.long.SVUID", "serialVersionUID 在类{0}中必须是 long 类型" }, { "compiler.warn.missing.SVUID", "可序列化类{0}没有 serialVersionUID 的定义" }, { "compiler.warn.missing.deprecated.annotation", "未使用 @Deprecated 对已过时的项目进行注释" }, { "compiler.warn.option.obsolete.source", "源值{0}已过时, 将在未来所有发行版中删除" }, { "compiler.warn.option.obsolete.suppression", "要隐藏有关已过时选项的警告, 请使用 -Xlint:-options。" }, { "compiler.warn.option.obsolete.target", "目标值{0}已过时, 将在未来所有发行版中删除" }, { "compiler.warn.override.bridge", "{0}; 被覆盖的方法为 bridge 方法" }, { "compiler.warn.override.equals.but.not.hashcode", "类{0}覆盖了 equals, 但该类或任何超类都未覆盖 hashCode 方法" }, { "compiler.warn.override.unchecked.ret", "{0}\n返回类型需要从{1}到{2}的未经检查的转换" }, { "compiler.warn.override.unchecked.thrown", "{0}\n被覆盖的方法未抛出{1}" }, { "compiler.warn.override.varargs.extra", "{0}; 覆盖的方法缺少 ''...''" }, { "compiler.warn.override.varargs.missing", "{0}; 被覆盖的方法没有 ''...''" }, { "compiler.warn.path.element.not.found", "错误的路径元素 \"{0}\": 没有这种文件或目录" }, { "compiler.warn.pkg-info.already.seen", "已找到程序包{0}的 package-info.java 文件" }, { "compiler.warn.position.overflow", "行 {0} 处的位置编码溢出" }, { "compiler.warn.possible.fall-through.into.case", "可能无法实现 case" }, { "compiler.warn.potentially.ambiguous.overload", "{1} 中的 {0} 可能与 {3} 中的 {2} 混淆" }, { "compiler.warn.prob.found.req", "{0}\n需要: {2}\n找到:    {1}" }, { "compiler.warn.proc.annotations.without.processors", "没有处理程序要使用以下任何注释: {0}" }, { "compiler.warn.proc.file.create.last.round", "将不对在最后一个循环中创建的类型为 ''{0}'' 的文件进行注释处理。" }, { "compiler.warn.proc.file.reopening", "尝试多次为 ''{0}'' 创建文件" }, { "compiler.warn.proc.illegal.file.name", "无法创建带有非法名称 ''{0}'' 的文件。" }, { "compiler.warn.proc.malformed.supported.string", "处理程序 ''{1}'' 为支持的注释类型返回格式错误的字符串 ''{0}''" }, { "compiler.warn.proc.messager", "{0}" }, { "compiler.warn.proc.package.does.not.exist", "程序包{0}不存在" }, { "compiler.warn.proc.proc-only.requested.no.procs", "在未请求编译的情况下进行注释处理, 但找不到处理程序。" }, { "compiler.warn.proc.processor.incompatible.source.version", "来自注释处理程序 ''{1}'' 的受支持 source 版本 ''{0}'' 低于 -source ''{2}''" }, { "compiler.warn.proc.suspicious.class.name", "正在为名称以{1}结尾的类型创建文件: ''{0}''" }, { "compiler.warn.proc.type.already.exists", "类型 ''{0}'' 的文件已经存在于源路径或类路径中" }, { "compiler.warn.proc.type.recreate", "尝试多次创建类型 ''{0}'' 的文件" }, { "compiler.warn.proc.unclosed.type.files", "类型 ''{0}'' 的文件未关闭; 将不针对这些类型进行注释处理" }, { "compiler.warn.proc.unmatched.processor.options", "以下选项未被任何处理程序识别: ''{0}''" }, { "compiler.warn.proc.use.implicit", "注释处理不适用于隐式编译的文件。\n使用 -implicit 指定用于隐式编译的策略。" }, { "compiler.warn.proc.use.proc.or.implicit", "注释处理不适用于隐式编译的文件。\n使用 -proc:none 禁用注释处理或使用 -implicit 指定用于隐式编译的策略。" }, { "compiler.warn.raw.class.use", "找到原始类型: {0}\n缺少泛型类{1}的类型参数" }, { "compiler.warn.redundant.cast", "出现冗余的到{0}的转换" }, { "compiler.warn.self.ref", "变量 ''{0}'' 的初始化程序中存在自引用" }, { "compiler.warn.source.no.bootclasspath", "未与 -source {0} 一起设置引导类路径" }, { "compiler.warn.static.not.qualified.by.type", "static {0}应由类型名称{1}而不是表达式限定" }, { "compiler.warn.sun.proprietary", "{0}是内部专用 API, 可能会在未来发行版中删除" }, { "compiler.warn.synthetic.name.conflict", "符号{0}与{1}中的 compiler-synthesized 符号冲突" }, { "compiler.warn.try.explicit.close.call", "在可自动结束的资源上显式调用 close()" }, { "compiler.warn.try.resource.not.referenced", "不能在相应的 try 语句的正文中引用可自动结束的资源{0}" }, { "compiler.warn.try.resource.throws.interrupted.exc", "可自动关闭的资源{0}包含的成员方法 close() 可能抛出 InterruptedException" }, { "compiler.warn.unchecked.assign", "未经检查的分配: 将{0}分配给{1}" }, { "compiler.warn.unchecked.assign.to.var", "对作为原始类型{1}的成员的变量{0}的分配未经过检查" }, { "compiler.warn.unchecked.call.mbr.of.raw.type", "对作为原始类型{1}的成员的{0}的调用未经过检查" }, { "compiler.warn.unchecked.cast.to.type", "向类型{0}的转换未经过检查" }, { "compiler.warn.unchecked.generic.array.creation", "对于类型为{0}的 varargs 参数, 泛型数组创建未经过检查" }, { "compiler.warn.unchecked.meth.invocation.applied", "方法调用未经过检查: 将{4} {5}中的{0} {1}应用到给定的类型\n需要: {2}\n找到: {3}" }, { "compiler.warn.unchecked.varargs.non.reifiable.type", "参数化 vararg 类型{0}的堆可能已受污染" }, { "compiler.warn.underscore.as.identifier", "''_'' 用作标识符\n(Java SE 8 之后的发行版中可能不支持使用 ''_'' 作为标识符)" }, { "compiler.warn.unexpected.archive.file", "以下档案文件存在意外的扩展名: {0}" }, { "compiler.warn.unknown.enum.constant", "未知的枚举常量 {1}.{2}" }, { "compiler.warn.unknown.enum.constant.reason", "未知的枚举常量 {1}.{2}\n原因: {3}" }, { "compiler.warn.unreachable.catch", "catch 子句无法访问\n已捕获到抛出的类型{0}" }, { "compiler.warn.unreachable.catch.1", "catch 子句无法访问\n已捕获到抛出的类型{0}" }, { "compiler.warn.varargs.redundant.trustme.anno", "冗余的 {0} 注释。{1}" }, { "compiler.warn.varargs.unsafe.use.varargs.param", "Varargs 方法可能导致来自不可具体化 varargs 参数 {0} 的堆污染" }, { "compiler.warn.warning", "警告: " } };
/*   */   }
/*   */ }


/* Location:              C:\Program Files\Java\jdk1.8.0_211\lib\tools.jar!\com\sun\tools\javac\resources\compiler_zh_CN.class
 * Java compiler version: 8 (52.0)
 * JD-Core Version:       1.1.3
 */