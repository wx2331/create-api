/*   */ package com.sun.tools.javac.resources;
/*   */ 
/*   */ public final class compiler_ja extends ListResourceBundle {
/*   */   protected final Object[][] getContents() {
/* 5 */     return new Object[][] { { "compiler.err.abstract.cant.be.accessed.directly", "抽象{0}である{1}({2}内)に直接アクセスすることはできません" }, { "compiler.err.abstract.cant.be.instantiated", "{0}はabstractです。インスタンスを生成することはできません" }, { "compiler.err.abstract.meth.cant.have.body", "abstractメソッドが本体を持つことはできません" }, { "compiler.err.already.annotated", "{0} {1}は注釈が付いています" }, { "compiler.err.already.defined", "{0} {1}はすでに{2} {3}で定義されています" }, { "compiler.err.already.defined.in.clinit", "{0} {1}はすでに{3} {4}の{2}で定義されています" }, { "compiler.err.already.defined.single.import", "同じ単純名の型が{0}の単一型インポートによってすでに定義されています" }, { "compiler.err.already.defined.static.single.import", "同じ単純名の型が{0}のstatic単一型インポートによってすでに定義されています" }, { "compiler.err.already.defined.this.unit", "{0}はコンパイル単位で定義されています" }, { "compiler.err.annotation.missing.default.value", "注釈@{0}には要素''{1}''のデフォルト値がありません" }, { "compiler.err.annotation.missing.default.value.1", "注釈@{0}には要素{1}のデフォルト値がありません" }, { "compiler.err.annotation.not.valid.for.type", "注釈は型{0}の要素に対して有効ではありません" }, { "compiler.err.annotation.type.not.applicable", "注釈型はこの種類の宣言に使用できません" }, { "compiler.err.annotation.value.must.be.annotation", "注釈の値は注釈である必要があります" }, { "compiler.err.annotation.value.must.be.class.literal", "注釈の値はクラス・リテラルである必要があります" }, { "compiler.err.annotation.value.must.be.name.value", "注釈の値は''name=value''という形式である必要があります" }, { "compiler.err.annotation.value.not.allowable.type", "使用できない型の注釈の値です" }, { "compiler.err.annotations.after.type.params.not.supported.in.source", "メソッド・タイプ・パラメータの後の注釈は-source {0}でサポートされていません\n(メソッド・タイプ・パラメータの後の注釈を使用可能にするには、-source 8以上を使用してください)" }, { "compiler.err.annotations.not.supported.in.source", "注釈は-source {0}でサポートされていません\n(注釈を使用可能にするには、-source 5以降を使用してください)" }, { "compiler.err.anon.class.impl.intf.no.args", "匿名クラスがインタフェースを実装しています。引数を持つことはできません" }, { "compiler.err.anon.class.impl.intf.no.qual.for.new", "匿名クラスがインタフェースを実装しています。newに修飾子を持つことはできません。" }, { "compiler.err.anon.class.impl.intf.no.typeargs", "匿名クラスがインタフェースを実装しています。型引数を持つことはできません" }, { "compiler.err.array.and.receiver", "旧式の配列表記法は受取り側パラメータでは使用できません" }, { "compiler.err.array.and.varargs", "{2}で{0}と{1}の両方を宣言することはできません" }, { "compiler.err.array.dimension.missing", "配列の大きさが指定されていません" }, { "compiler.err.array.req.but.found", "配列が要求されましたが、{0}が見つかりました" }, { "compiler.err.assert.as.identifier", "リリース1.4から''assert''はキーワードなので、識別子として使用することはできません\n(''assert''を識別子として使用するには、-source 1.3以前を使用してください)" }, { "compiler.err.attribute.value.must.be.constant", "要素値は定数式である必要があります" }, { "compiler.err.bad.functional.intf.anno", "予期しない@FunctionalInterface注釈" }, { "compiler.err.bad.functional.intf.anno.1", "予期しない@FunctionalInterface注釈\n{0}" }, { "compiler.err.bad.initializer", "{0}の不正な初期化子" }, { "compiler.err.break.outside.switch.loop", "breakがswitch文またはループの外にあります" }, { "compiler.err.call.must.be.first.stmt.in.ctor", "{0}の呼出しはコンストラクタの先頭文である必要があります" }, { "compiler.err.call.to.super.not.allowed.in.enum.ctor", "列挙型コンストラクタでは、スーパークラスの呼出しはできません" }, { "compiler.err.cannot.create.array.with.diamond", "''<>''を持つ配列は作成できません" }, { "compiler.err.cannot.create.array.with.type.arguments", "型引数を持つ配列を作成できません" }, { "compiler.err.cant.access", "{0}にアクセスできません\n{1}" }, { "compiler.err.cant.apply.diamond", "{0}の型引数を推論できません" }, { "compiler.err.cant.apply.diamond.1", "{0}の型引数を推論できません\n理由: {1}" }, { "compiler.err.cant.apply.symbol", "{4} {5}の{0} {1}は指定された型に適用できません。\n期待値: {2}\n検出値: {3}\n理由: {6}" }, { "compiler.err.cant.apply.symbols", "{1}に適切な{0}が見つかりません({2})" }, { "compiler.err.cant.assign.val.to.final.var", "final変数{0}に値を代入することはできません" }, { "compiler.err.cant.deref", "{0}は間接参照できません" }, { "compiler.err.cant.extend.intf.annotation", "@interfacesでは''extends''は許可されません" }, { "compiler.err.cant.inherit.diff.arg", "{0}を異なる引数<{1}>と<{2}>で継承することはできません" }, { "compiler.err.cant.inherit.from.anon", "匿名クラスから継承できません" }, { "compiler.err.cant.inherit.from.final", "final {0}からは継承できません" }, { "compiler.err.cant.read.file", "{0}を読み込めません" }, { "compiler.err.cant.ref.before.ctor.called", "スーパータイプのコンストラクタの呼出し前は{0}を参照できません" }, { "compiler.err.cant.ref.non.effectively.final.var", "{1}から参照されるローカル変数は、finalまたは事実上のfinalである必要があります" }, { "compiler.err.cant.resolve", "シンボルを見つけられません\nシンボル: {0} {1}" }, { "compiler.err.cant.resolve.args", "シンボルを見つけられません\nシンボル: {0} {1}({3})" }, { "compiler.err.cant.resolve.args.params", "シンボルを見つけられません\nシンボル: {0} <{2}>{1}({3})" }, { "compiler.err.cant.resolve.location", "シンボルを見つけられません\nシンボル:   {0} {1}\n場所: {4}" }, { "compiler.err.cant.resolve.location.args", "シンボルを見つけられません\nシンボル:   {0} {1}({3})\n場所: {4}" }, { "compiler.err.cant.resolve.location.args.params", "シンボルを見つけられません\nシンボル:   {0} <{2}>{1}({3})\n場所: {4}" }, { "compiler.err.cant.select.static.class.from.param.type", "パラメータにされた型からstaticクラスを選択することはできません" }, { "compiler.err.cant.type.annotate.scoping", "スコープ・コンストラクトを型使用注釈で注釈付けすることはできません: {0}" }, { "compiler.err.cant.type.annotate.scoping.1", "スコープ・コンストラクトを型使用注釈で注釈付けすることはできません: {0}" }, { "compiler.err.catch.without.try", "''catch''への''try''がありません" }, { "compiler.err.clash.with.pkg.of.same.name", "{0} {1}は同名のパッケージと競合します" }, { "compiler.err.class.cant.write", "{0}の書込み中にエラーが発生しました: {1}" }, { "compiler.err.class.not.allowed", "クラス、インタフェースまたは列挙型の宣言をここで使用することはできません" }, { "compiler.err.class.public.should.be.in.file", "クラス{0}はpublicであり、ファイル{0}.javaで宣言する必要があります" }, { "compiler.err.concrete.inheritance.conflict", "{1}のメソッド{0}と{3}の{2}は同じシグネチャから継承されています" }, { "compiler.err.const.expr.req", "定数式が必要です" }, { "compiler.err.cont.outside.loop", "continueがループの外にあります" }, { "compiler.err.cyclic.annotation.element", "要素{0}の型がループしています" }, { "compiler.err.cyclic.inheritance", "{0}を含む継承がループしています" }, { "compiler.err.dc.bad.entity", "HTMLエンティティが不正です" }, { "compiler.err.dc.bad.gt", "''>''の使用が不正です" }, { "compiler.err.dc.bad.inline.tag", "インライン・タグの使用が正しくありません" }, { "compiler.err.dc.gt.expected", "''>''が必要です" }, { "compiler.err.dc.identifier.expected", "識別子が必要です" }, { "compiler.err.dc.malformed.html", "HTMLが不正です" }, { "compiler.err.dc.missing.semicolon", "セミコロンがありません" }, { "compiler.err.dc.no.content", "コンテンツなし" }, { "compiler.err.dc.no.tag.name", "'@'の後にタグ名がありません" }, { "compiler.err.dc.ref.bad.parens", "参照に'')''がありません" }, { "compiler.err.dc.ref.syntax.error", "参照に構文エラーがあります" }, { "compiler.err.dc.ref.unexpected.input", "予期しないテキストです" }, { "compiler.err.dc.unexpected.content", "予期しないコンテンツです" }, { "compiler.err.dc.unterminated.inline.tag", "インライン・タグが終了していません" }, { "compiler.err.dc.unterminated.signature", "シグネチャが終了していません" }, { "compiler.err.dc.unterminated.string", "文字列が終了していません" }, { "compiler.err.default.allowed.in.intf.annotation.member", "デフォルト値は注釈型の宣言でのみ使用できます" }, { "compiler.err.default.methods.not.supported.in.source", "デフォルト・メソッドは-source {0}でサポートされていません\n(デフォルト・メソッドを使用可能にするには、-source 8以上を使用してください)" }, { "compiler.err.default.overrides.object.member", "{1} {2}のデフォルト・メソッド{0}はjava.lang.Objectのメンバーをオーバーライドします" }, { "compiler.err.diamond.not.supported.in.source", "ダイヤモンド演算子は-source {0}でサポートされていません\n(ダイヤモンド演算子を使用可能にするには、-source 7以降を使用してください)" }, { "compiler.err.does.not.override.abstract", "{0}はabstractでなく、{2}内のabstractメソッド{1}をオーバーライドしません" }, { "compiler.err.doesnt.exist", "パッケージ{0}は存在しません" }, { "compiler.err.dot.class.expected", "''.class''がありません" }, { "compiler.err.duplicate.annotation.invalid.repeated", "注釈{0}は有効な繰返し可能な注釈ではありません" }, { "compiler.err.duplicate.annotation.member.value", "注釈@{1}に重複した要素''{0}''があります。" }, { "compiler.err.duplicate.annotation.missing.container", "{0}は繰返し可能な注釈型ではありません" }, { "compiler.err.duplicate.case.label", "caseラベルが重複しています" }, { "compiler.err.duplicate.class", "クラス{0}が重複しています" }, { "compiler.err.duplicate.default.label", "defaultラベルが重複しています" }, { "compiler.err.else.without.if", "''else''への''if''がありません" }, { "compiler.err.empty.char.lit", "空の文字リテラルです" }, { "compiler.err.encl.class.required", "{0}を含む囲うインスタンスが必要です" }, { "compiler.err.enum.annotation.must.be.enum.constant", "列挙型注釈値は、列挙型定数である必要があります" }, { "compiler.err.enum.as.identifier", "リリース5から''enum''はキーワードなので識別子として使用することはできません\n(''enum''を識別子として使用するには-source 1.4以前を使用してください)" }, { "compiler.err.enum.cant.be.instantiated", "列挙型はインスタンス化できません" }, { "compiler.err.enum.label.must.be.unqualified.enum", "列挙型のswitch caseラベルは列挙型定数の非修飾名である必要があります" }, { "compiler.err.enum.no.finalize", "列挙型はfinalizeメソッドを持つことはできません" }, { "compiler.err.enum.no.subclassing", "クラスは直接java.lang.Enumを拡張できません" }, { "compiler.err.enum.types.not.extensible", "列挙型は拡張可能ではありません" }, { "compiler.err.enums.must.be.static", "列挙型の宣言はstaticコンテキストでのみ使用できます" }, { "compiler.err.enums.not.supported.in.source", "列挙型は-source {0}でサポートされていません\n(列挙型を使用可能にするには-source 5以降を使用してください)" }, { "compiler.err.error", "エラー: " }, { "compiler.err.error.reading.file", "{0}の読込みエラーです。{1}" }, { "compiler.err.except.already.caught", "例外{0}はすでに捕捉されています" }, { "compiler.err.except.never.thrown.in.try", "例外{0}は対応するtry文の本体ではスローされません" }, { "compiler.err.expected", "{0}がありません" }, { "compiler.err.expected2", "{0}または{1}がありません" }, { "compiler.err.expected3", "{0}、{1}または{2}がありません" }, { "compiler.err.final.parameter.may.not.be.assigned", "finalパラメータ{0}に値を代入することはできません" }, { "compiler.err.finally.without.try", "''finally''への''try''がありません" }, { "compiler.err.foreach.not.applicable.to.type", "for-eachは式のタイプに使用できません\n期待値: {1}\n検出値: {0}" }, { "compiler.err.foreach.not.supported.in.source", "拡張forループは-source {0}でサポートされていません\n(for-eachループを使用可能にするには、-source 5以降を使用してください)" }, { "compiler.err.fp.number.too.large", "浮動小数点数が大きすぎます" }, { "compiler.err.fp.number.too.small", "浮動小数点数が小さすぎます" }, { "compiler.err.generic.array.creation", "汎用配列を作成します" }, { "compiler.err.generic.throwable", "汎用クラスはjava.lang.Throwableを拡張できません" }, { "compiler.err.generics.not.supported.in.source", "総称型は-source {0}でサポートされていません\n(総称型を使用可能にするには、-source 5以降を使用してください)" }, { "compiler.err.icls.cant.have.static.decl", "内部クラス{0}の静的宣言が不正です\n修飾子''static''は定数および変数の宣言でのみ使用できます" }, { "compiler.err.illegal.char", "''{0}''は不正な文字です" }, { "compiler.err.illegal.char.for.encoding", "この文字は、エンコーディング{0}にマップできません" }, { "compiler.err.illegal.combination.of.modifiers", "修飾子{0}と{1}の組合せは不正です" }, { "compiler.err.illegal.default.super.call", "デフォルトのスーパー・コールの型修飾子{0}が不正です\n{1}" }, { "compiler.err.illegal.dot", "不正な''.''です" }, { "compiler.err.illegal.enum.static.ref", "初期化子からstaticフィールドへの参照が不正です" }, { "compiler.err.illegal.esc.char", "エスケープ文字が不正です" }, { "compiler.err.illegal.forward.ref", "前方参照が不正です" }, { "compiler.err.illegal.generic.type.for.instof", "instanceofの総称型が不正です" }, { "compiler.err.illegal.initializer.for.type", "{0}の初期化子が不正です" }, { "compiler.err.illegal.line.end.in.char.lit", "文字リテラルの行末が不正です" }, { "compiler.err.illegal.nonascii.digit", "不正な非ASCII数字です" }, { "compiler.err.illegal.qual.not.icls", "修飾子が不正です。{0}は内部クラスではありません" }, { "compiler.err.illegal.self.ref", "初期化子内の自己参照" }, { "compiler.err.illegal.start.of.expr", "式の開始が不正です" }, { "compiler.err.illegal.start.of.stmt", "文の開始が不正です" }, { "compiler.err.illegal.start.of.type", "型の開始が不正です" }, { "compiler.err.illegal.static.intf.meth.call", "staticインタフェース・メソッド・コールが不正です\n受信式は型修飾子''{0}''で置換される必要があります" }, { "compiler.err.illegal.underscore", "不正なアンダースコアです" }, { "compiler.err.illegal.unicode.esc", "Unicodeエスケープが不正です" }, { "compiler.err.import.requires.canonical", "インポートには{0}の標準名が必要です" }, { "compiler.err.improperly.formed.type.inner.raw.param", "型の形式が不適切です。raw型に指定された型引数です" }, { "compiler.err.improperly.formed.type.param.missing", "型の形式が不適切です。パラメータが不足しています" }, { "compiler.err.incomparable.types", "型{0}と{1}は比較できません" }, { "compiler.err.incompatible.thrown.types.in.mref", "メソッド参照のスローされたタイプ{0}は不適合です" }, { "compiler.err.incorrect.constructor.receiver.name", "受取り側の名前が、包含する外部クラス・タイプと一致しません\n必須: {0}\n検出: {1}" }, { "compiler.err.incorrect.constructor.receiver.type", "受取り側のタイプが、包含する外部クラス・タイプと一致しません\n必須: {0}\n検出: {1}" }, { "compiler.err.incorrect.receiver.name", "受取り側の名前が、包含するクラス・タイプと一致しません\n必須: {0}\n検出: {1}" }, { "compiler.err.incorrect.receiver.type", "受取り側のタイプが、包含するクラス・タイプと一致しません\n必須: {0}\n検出: {1}" }, { "compiler.err.initializer.must.be.able.to.complete.normally", "初期化子は正常に完了できる必要があります" }, { "compiler.err.int.number.too.large", "整数{0}が大きすぎます" }, { "compiler.err.intersection.types.in.cast.not.supported.in.source", "キャスト内のintersection型は-source {0}でサポートされていません\n(デフォルト・メソッドを使用可能にするには、-source 8以上を使用してください)" }, { "compiler.err.intf.annotation.cant.have.type.params", "注釈型{0}は汎用にできません" }, { "compiler.err.intf.annotation.member.clash", "注釈型{1}でメソッド{0}と同じ名前の要素が宣言されています" }, { "compiler.err.intf.annotation.members.cant.have.params", "注釈型宣言内の要素が仮パラメータを宣言できません" }, { "compiler.err.intf.annotation.members.cant.have.type.params", "注釈型宣言内の要素は汎用メソッドにできません" }, { "compiler.err.intf.expected.here", "ここにインタフェースが必要です" }, { "compiler.err.intf.meth.cant.have.body", "インタフェース抽象メソッドが本体を持つことはできません" }, { "compiler.err.intf.not.allowed.here", "ここではインタフェースは許可されません" }, { "compiler.err.invalid.annotation.member.type", "注釈型の要素{0}の型が無効です" }, { "compiler.err.invalid.binary.number", "2進数字は少なくとも1桁の2進数を含む必要があります" }, { "compiler.err.invalid.hex.number", "16進数字は少なくとも1桁の16進数を含む必要があります" }, { "compiler.err.invalid.meth.decl.ret.type.req", "無効なメソッド宣言です。戻り値の型が必要です。" }, { "compiler.err.invalid.mref", "{0}参照が無効です\n{1}" }, { "compiler.err.invalid.repeatable.annotation", "注釈が重複しています: {0}は無効な@Repeatable注釈で注釈付けされています" }, { "compiler.err.invalid.repeatable.annotation.elem.nondefault", "包含する注釈型{0}には要素{1}のデフォルト値が指定されていません" }, { "compiler.err.invalid.repeatable.annotation.incompatible.target", "包含する注釈型({0})は、繰返し可能な注釈型({1})より多くのターゲットに適用されます" }, { "compiler.err.invalid.repeatable.annotation.invalid.value", "{0}は有効な@Repeatableではありません: 値要素が無効です" }, { "compiler.err.invalid.repeatable.annotation.multiple.values", "{0}は有効な@Repeatableではありません。{1}要素メソッド''value''が宣言されています" }, { "compiler.err.invalid.repeatable.annotation.no.value", "{0}は有効な@Repeatableではありません。値要素メソッドが宣言されていません" }, { "compiler.err.invalid.repeatable.annotation.not.documented", "繰返し可能な注釈型({1})は@Documentedですが、包含する注釈型({0})は違います" }, { "compiler.err.invalid.repeatable.annotation.not.inherited", "繰返し可能な注釈型({1})は@Inheritedですが、包含する注釈型({0})は違います" }, { "compiler.err.invalid.repeatable.annotation.repeated.and.container.present", "コンテナ{0}は含まれている要素と同時に指定できません" }, { "compiler.err.invalid.repeatable.annotation.retention", "包含する注釈型({0})の保有が、繰返し可能な注釈型({2})の保有より短くなっています" }, { "compiler.err.invalid.repeatable.annotation.value.return", "包含する注釈型({0})は型{2}の要素''value''を宣言する必要があります" }, { "compiler.err.io.exception", "ソース・ファイルの読取りエラーです: {0}" }, { "compiler.err.label.already.in.use", "ラベル{0}はすでに使用されています" }, { "compiler.err.lambda.body.neither.value.nor.void.compatible", "ラムダ・ボディは値互換でもvoid互換でもありません" }, { "compiler.err.lambda.not.supported.in.source", "ラムダ式は-source {0}でサポートされていません\n(ラムダ式を使用可能にするには、-source 8以上を使用してください)" }, { "compiler.err.limit.code", "コードが大きすぎます" }, { "compiler.err.limit.code.too.large.for.try.stmt", "try文のコードが大きすぎます" }, { "compiler.err.limit.dimensions", "配列型の次元が多すぎます" }, { "compiler.err.limit.locals", "ローカル変数が多すぎます" }, { "compiler.err.limit.parameters", "パラメータが多すぎます" }, { "compiler.err.limit.pool", "定数が多すぎます" }, { "compiler.err.limit.pool.in.class", "クラス{0}内の定数が多すぎます" }, { "compiler.err.limit.stack", "コードが要求するスタックが多すぎます" }, { "compiler.err.limit.string", "定数文字列が長すぎます" }, { "compiler.err.limit.string.overflow", "文字列\"{0}...\"のUTF8表現が、定数プールに対して長すぎます" }, { "compiler.err.local.enum", "列挙型はローカルにできません" }, { "compiler.err.local.var.accessed.from.icls.needs.final", "ローカル変数{0}は内部クラスからアクセスされます。finalで宣言される必要があります" }, { "compiler.err.malformed.fp.lit", "浮動小数点リテラルが不正です" }, { "compiler.err.method.does.not.override.superclass", "メソッドはスーパータイプのメソッドをオーバーライドまたは実装しません" }, { "compiler.err.method.invoked.with.incorrect.number.arguments", "メソッドを起動した引数の数が正しくありません。予期される数は{0}ですが、{1}が見つかりました" }, { "compiler.err.method.references.not.supported.in.source", "メソッド参照は-source {0}でサポートされていません\n(メソッド参照を使用可能にするには、-source 8以上を使用してください)" }, { "compiler.err.missing.meth.body.or.decl.abstract", "メソッド本体がないか、abstractとして宣言されています" }, { "compiler.err.missing.ret.stmt", "return文が指定されていません" }, { "compiler.err.mod.not.allowed.here", "修飾子{0}をここで使用することはできません" }, { "compiler.err.multicatch.not.supported.in.source", "複数catch文は-source {0}でサポートされていません\n(複数catch文を使用可能にするには、-source 7以降を使用してください)" }, { "compiler.err.multicatch.parameter.may.not.be.assigned", "複数catchパラメータ{0}に値を代入することはできません" }, { "compiler.err.multicatch.types.must.be.disjoint", "複数catch文の代替をサブクラス化によって関連付けることはできません\n代替{0}は代替{1}のサブクラスです" }, { "compiler.err.name.clash.same.erasure", "名前が競合しています。{0}と{1}は削除後の名前が同じです" }, { "compiler.err.name.clash.same.erasure.no.hide", "名前が競合しています。{1}の{0}と{3}の{2}はまだ他方を非表示にしていませんが、削除後の名前が同じです" }, { "compiler.err.name.clash.same.erasure.no.override", "名前が競合しています。{1}の{0}と{3}の{2}はまだ他方をオーバーライドしていませんが、削除後の名前が同じです" }, { "compiler.err.name.clash.same.erasure.no.override.1", "名前が競合しています。{1}の{0}のどちらも、他方の最初のメソッドをまだオーバーライドしていませんが、削除後の名前が別のメソッドと同じメソッドを\nオーバーライドします。最初のメソッド: {3}の{2}\n2番目のメソッド: {5}の{4}" }, { "compiler.err.name.reserved.for.internal.use", "{0}は内部での使用のため予約されています" }, { "compiler.err.native.meth.cant.have.body", "nativeメソッドが本体を持つことはできません" }, { "compiler.err.neither.conditional.subtype", "?に対する不適合な型 : どちらも他方のサブタイプではありません。\n2番目のオペランド : {0}\n3番目のオペランド : {1}" }, { "compiler.err.new.not.allowed.in.annotation", "''new''は注釈に使用できません" }, { "compiler.err.no.annotation.member", "{1}の注釈メンバー{0}がありません" }, { "compiler.err.no.annotations.on.dot.class", "注釈はクラス・リテラルのタイプで許可されません" }, { "compiler.err.no.encl.instance.of.type.in.scope", "型{0}の内部クラスを囲むインスタンスがスコープ内にありません" }, { "compiler.err.no.intf.expected.here", "ここにインタフェースは必要ありません" }, { "compiler.err.no.match.entry", "{0}は{1}のエントリに適合しません。{2}が必要です" }, { "compiler.err.no.superclass", "{0}にはスーパークラスがありません。" }, { "compiler.err.non-static.cant.be.ref", "staticでない{0} {1}をstaticコンテキストから参照することはできません" }, { "compiler.err.not.annotation.type", "{0}は注釈型ではありません" }, { "compiler.err.not.def.access.class.intf.cant.access", "{1}の{0}がアクセスできないクラスまたはインタフェースに定義されています" }, { "compiler.err.not.def.public.cant.access", "{1}の{0}はpublicではありません。パッケージ外からはアクセスできません" }, { "compiler.err.not.encl.class", "{0}は内部クラスを囲みません" }, { "compiler.err.not.in.profile", "{0}はプロファイル''{1}''で使用できません" }, { "compiler.err.not.loop.label", "{0}はループ・ラベルではありません" }, { "compiler.err.not.stmt", "文ではありません" }, { "compiler.err.not.within.bounds", "型引数{0}は型変数{1}の境界内にありません" }, { "compiler.err.operator.cant.be.applied", "単項演算子''{0}''のオペランド型{1}が不正です" }, { "compiler.err.operator.cant.be.applied.1", "二項演算子''{0}''のオペランド型が不正です\n最初の型: {1}\n2番目の型: {2}" }, { "compiler.err.orphaned", "{0}には親がありません" }, { "compiler.err.override.incompatible.ret", "{0}\n戻り値の型{1}は{2}と互換性がありません" }, { "compiler.err.override.meth", "{0}\nオーバーライドされたメソッドは{1}です" }, { "compiler.err.override.meth.doesnt.throw", "{0}\nオーバーライドされたメソッドは{1}をスローしません" }, { "compiler.err.override.static", "{0}\nオーバーライドするメソッドがstaticです" }, { "compiler.err.override.weaker.access", "{0}\n({1})より弱いアクセス権限を割り当てようとしました" }, { "compiler.err.pkg.annotations.sb.in.package-info.java", "パッケージの注釈はファイルpackage-info.java内にある必要があります" }, { "compiler.err.pkg.clashes.with.class.of.same.name", "パッケージ{0}は同名のクラスと競合しています" }, { "compiler.err.premature.eof", "構文解析中にファイルの終わりに移りました" }, { "compiler.err.prob.found.req", "不適合な型: {0}" }, { "compiler.err.proc.bad.config.file", "サービス構成ファイルが不正であるか、プロセッサ・オブジェクトの構築中に例外がスローされました: {0}" }, { "compiler.err.proc.cant.access", "{0}にアクセスできません\n{1}\n詳細は次のスタック・トレースで調査してください。\n{2}" }, { "compiler.err.proc.cant.access.1", "{0}にアクセスできません\n{1}" }, { "compiler.err.proc.cant.create.loader", "注釈プロセッサのクラス・ローダーを作成できませんでした: {0}" }, { "compiler.err.proc.cant.find.class", "''{0}''のクラス・ファイルが見つかりませんでした。" }, { "compiler.err.proc.messager", "{0}" }, { "compiler.err.proc.no.explicit.annotation.processing.requested", "クラス名''{0}''が受け入れられるのは、注釈処理が明示的にリクエストされた場合のみです" }, { "compiler.err.proc.no.service", "サービス・ローダーが使用できませんでしたが、注釈処理に必要です。" }, { "compiler.err.proc.processor.bad.option.name", "プロセッサ''{1}''によって指定されたオプション名''{0}''が不正です" }, { "compiler.err.proc.processor.cant.instantiate", "プロセッサ''{0}''のインスタンスをインスタンス化できませんでした" }, { "compiler.err.proc.processor.not.found", "注釈プロセッサ''{0}''が見つかりません" }, { "compiler.err.proc.processor.wrong.type", "注釈プロセッサ''{0}''がjavax.annotation.processing.Processorを実装していません" }, { "compiler.err.proc.service.problem", "プロセッサをロードするためのサービス・ローダーを作成中にエラーが発生しました。" }, { "compiler.err.qualified.new.of.static.class", "staticクラスのnewが修飾されています" }, { "compiler.err.receiver.parameter.not.applicable.constructor.toplevel.class", "受取り側パラメータは最上位レベル・クラスのコンストラクタに適用できません" }, { "compiler.err.recursive.ctor.invocation", "コンストラクタの呼出しが再帰的です" }, { "compiler.err.ref.ambiguous", "{0}の参照はあいまいです\n{3}の{1} {2}と{6}の{4} {5}の両方が一致します" }, { "compiler.err.repeatable.annotations.not.supported.in.source", "繰返し注釈は-source {0}でサポートされていません\n(繰返し注釈を使用可能にするには、-source 8以上を使用してください)" }, { "compiler.err.repeated.annotation.target", "注釈ターゲットが繰り返されています" }, { "compiler.err.repeated.interface", "インタフェースが繰り返されています" }, { "compiler.err.repeated.modifier", "修飾子が繰り返されています" }, { "compiler.err.report.access", "{0}は{2}で{1}アクセスされます" }, { "compiler.err.ret.outside.meth", "メソッドの外のreturn文です" }, { "compiler.err.signature.doesnt.match.intf", "シグネチャが{0}に一致しません。不適合なインタフェースです" }, { "compiler.err.signature.doesnt.match.supertype", "シグネチャが{0}に一致しません。不適合なスーパータイプです" }, { "compiler.err.source.cant.overwrite.input.file", "ソースの書込みエラーです。入力ファイル{0}を上書きできません" }, { "compiler.err.stack.sim.error", "内部エラー: {0}でのスタック・シミュレーション・エラー" }, { "compiler.err.static.imp.only.classes.and.interfaces", "static importはクラスとインタフェースからのみとなります" }, { "compiler.err.static.import.not.supported.in.source", "static import宣言は -source {0}でサポートされていません\n(static import宣言を使用可能にするには、-source 5以降を使用してください)" }, { "compiler.err.static.intf.method.invoke.not.supported.in.source", "staticインタフェース・メソッド呼出しは-source {0}でサポートされていません\n(staticインタフェース・メソッド呼出しを使用可能にするには、-source 8以上を使用してください)" }, { "compiler.err.static.intf.methods.not.supported.in.source", "staticインタフェースは-source {0}でサポートされていません\n(staticインタフェースを使用可能にするには、-source 8以上を使用してください)" }, { "compiler.err.string.const.req", "定数の文字列式が必要です" }, { "compiler.err.string.switch.not.supported.in.source", "switch内の文字列は-source {0}でサポートされていません\n(switch内の文字列を使用可能にするには、-source 7以降を使用してください)" }, { "compiler.err.synthetic.name.conflict", "シンボル{0}が、{1}でコンパイラが合成したシンボルと競合します" }, { "compiler.err.this.as.identifier", "リリース8から''this''は受信タイプのパラメータ名としてのみ許可され、最初のパラメータにする必要があります" }, { "compiler.err.throws.not.allowed.in.intf.annotation", "throws節を@interfaceメンバーで使用することはできません" }, { "compiler.err.try.resource.may.not.be.assigned", "自動クローズ可能なリソース{0}に値を代入することはできません" }, { "compiler.err.try.with.resources.not.supported.in.source", "try-with-resourceは-source {0}でサポートされていません\n(try-with-resourceを使用可能にするには、-source 7以降を使用してください)" }, { "compiler.err.try.without.catch.finally.or.resource.decls", "''try''への''catch''、''finally''またはリソース宣言がありません" }, { "compiler.err.try.without.catch.or.finally", "''try''への''catch''または''finally''がありません" }, { "compiler.err.type.annotations.not.supported.in.source", "タイプ注釈は-source {0}でサポートされていません\n(タイプ注釈を使用可能にするには、-source 8以上を使用してください)" }, { "compiler.err.type.doesnt.take.params", "型{0}はパラメータをとりません" }, { "compiler.err.type.found.req", "予期しない型\n期待値: {1}\n検出値:    {0}" }, { "compiler.err.type.var.cant.be.deref", "型変数から選択できません" }, { "compiler.err.type.var.may.not.be.followed.by.other.bounds", "この型変数の後ろに他の境界を配置することはできません" }, { "compiler.err.type.var.more.than.once", "型変数{0}は{1}の戻り値の型で2回以上出現します。インスタンス生成されないままにはできません" }, { "compiler.err.type.var.more.than.once.in.result", "型変数{0}は{1}の型で2回以上出現します。インスタンス生成されないままにはできません" }, { "compiler.err.types.incompatible.abstract.default", "{0} {1}は型{4}と{5}から{2}({3})の抽象とデフォルトを継承します" }, { "compiler.err.types.incompatible.diff.ret", "型{0}と型{1}が適合していません。両方とも{2}を定義していますが、戻り値の型が無関係です" }, { "compiler.err.types.incompatible.unrelated.defaults", "{0} {1}は型{4}と{5}から{2}({3})の関連しないデフォルトを継承します" }, { "compiler.err.unclosed.char.lit", "文字リテラルが閉じられていません" }, { "compiler.err.unclosed.comment", "コメントが閉じられていません" }, { "compiler.err.unclosed.str.lit", "文字列リテラルが閉じられていません" }, { "compiler.err.undef.label", "ラベル{0}は未定義です" }, { "compiler.err.underscore.as.identifier.in.lambda", "''_''が識別子として使用されています\n(ラムダ・パラメータでは''_''を識別子として使用することは禁止されています)" }, { "compiler.err.unexpected.lambda", "ここではラムダ式は予期されていません" }, { "compiler.err.unexpected.mref", "ここではメソッド参照は予期されていません" }, { "compiler.err.unexpected.type", "予期しない型\n期待値: {0}\n検出値:    {1}" }, { "compiler.err.unreachable.stmt", "この文に制御が移ることはありません" }, { "compiler.err.unreported.exception.default.constructor", "デフォルトのコンストラクタ内に報告されない例外{0}が存在します" }, { "compiler.err.unreported.exception.implicit.close", "報告されない例外{0}は、スローするには捕捉または宣言する必要があります\nリソース変数''{1}''でのclose()の暗黙的なコールから例外がスローされました" }, { "compiler.err.unreported.exception.need.to.catch.or.throw", "例外{0}は報告されません。スローするには、捕捉または宣言する必要があります" }, { "compiler.err.unsupported.binary.lit", "2進数リテラルは-source {0}でサポートされていません\n(2進数リテラルを使用可能にするには-source 7以降を使用してください)" }, { "compiler.err.unsupported.cross.fp.lit", "16進浮動小数点リテラルはこのVMではサポートされていません" }, { "compiler.err.unsupported.encoding", "サポートされていないエンコーディングです: {0}" }, { "compiler.err.unsupported.fp.lit", "16進数浮動小数点リテラルは-source {0}でサポートされていません\n(16進数浮動小数点リテラルを使用可能にするには、-source 5以降を使用してください)" }, { "compiler.err.unsupported.underscore.lit", "リテラル内のアンダースコアは-source {0}でサポートされていません\n(リテラル内のアンダースコアを使用可能にするには、-source 7以降を使用してください)" }, { "compiler.err.var.might.already.be.assigned", "変数{0}はすでに代入されている可能性があります" }, { "compiler.err.var.might.be.assigned.in.loop", "変数{0}はループ内で代入されている可能性があります" }, { "compiler.err.var.might.not.have.been.initialized", "変数{0}は初期化されていない可能性があります" }, { "compiler.err.var.not.initialized.in.default.constructor", "変数{0}は、デフォルト・コンストラクタで初期化されていません" }, { "compiler.err.varargs.and.old.array.syntax", "旧式の配列表記法は可変引数パラメータでは使用できません" }, { "compiler.err.varargs.and.receiver", "varargs表記は受取り側パラメータで使用できません" }, { "compiler.err.varargs.invalid.trustme.anno", "{0}注釈が無効です。{1}" }, { "compiler.err.varargs.not.supported.in.source", "可変引数メソッドは-source {0}でサポートされていません\n(可変引数メソッドを使用可能にするには、-source 5以降を使用してください)" }, { "compiler.err.variable.not.allowed", "変数の宣言をここで使用することはできません" }, { "compiler.err.void.not.allowed.here", "ここで''void''型を使用することはできません" }, { "compiler.err.warnings.and.werror", "警告が見つかり-Werrorが指定されました" }, { "compiler.err.wrong.number.type.args", "型引数の数が不正です。{0}個必要です" }, { "compiler.misc.anonymous.class", "<anonymous {0}>" }, { "compiler.misc.applicable.method.found", "#{0}個の使用可能メソッドが見つかりました: {1}" }, { "compiler.misc.applicable.method.found.1", "#{0}個の使用可能メソッドが見つかりました: {1}\n({2})" }, { "compiler.misc.arg.length.mismatch", "実引数リストと仮引数リストの長さが異なります" }, { "compiler.misc.bad.class.file.header", "クラス・ファイル{0}は不正です\n{1}\n削除するか、クラスパスの正しいサブディレクトリにあるかを確認してください。" }, { "compiler.misc.bad.class.signature", "クラス{0}のシグネチャが不正です" }, { "compiler.misc.bad.const.pool.entry", "{0}の定数プール・エントリが不正です\n索引{2}では{1}が必要です" }, { "compiler.misc.bad.const.pool.tag", "定数プール・タグ{0}が不正です" }, { "compiler.misc.bad.const.pool.tag.at", "定数プール・タグ{1}での{0}が不正です" }, { "compiler.misc.bad.enclosing.class", "{0}の内部クラスが不正です: {1}" }, { "compiler.misc.bad.enclosing.method", "クラス{0}の囲んでいるメソッド属性が不正です" }, { "compiler.misc.bad.intersection.target.for.functional.expr", "ラムダまたはメソッド参照の交差タイプ・ターゲットが不正です\n{0}" }, { "compiler.misc.bad.runtime.invisible.param.annotations", "RuntimeInvisibleParameterAnnotations属性が不正です: {0}" }, { "compiler.misc.bad.signature", "シグネチャ{0}が不正です" }, { "compiler.misc.bad.source.file.header", "ソース・ファイル{0}は不正です\n{1}\n削除するか、ソース・パスの正しいサブディレクトリにあるかを確認してください。" }, { "compiler.misc.bad.type.annotation.value", "注釈ターゲット型の値の型が不正です: {0}" }, { "compiler.misc.base.membership", "すべてのベース・クラスがメンバーです" }, { "compiler.misc.cant.access.inner.cls.constr", "コンストラクタ{0}({1})にアクセスできません\n内部クラスを囲む型{2}のインスタンスがスコープ内にありません" }, { "compiler.misc.cant.apply.diamond.1", "{0}の型引数を推論できません\n理由: {1}" }, { "compiler.misc.cant.apply.symbol", "{4} {5}の{0} {1}は指定された型に適用できません\n期待値: {2}\n検出値: {3}\n理由: {6}" }, { "compiler.misc.cant.apply.symbols", "{1}に適切な{0}が見つかりません({2})" }, { "compiler.misc.cant.implement", "{1}の{0}は{3}の{2}を実装できません" }, { "compiler.misc.cant.override", "{1}の{0}は{3}の{2}をオーバーライドできません" }, { "compiler.misc.cant.resolve.location.args", "シンボルを見つけられません\nシンボル:   {0} {1}({3})\n場所: {4}" }, { "compiler.misc.cant.resolve.location.args.params", "シンボルを見つけられません\nシンボル:   {0} <{2}>{1}({3})\n場所: {4}" }, { "compiler.misc.captured.type", "CAP#{0}" }, { "compiler.misc.ccf.found.later.version", "クラス・ファイル{0}に予想外の新バージョンがあります" }, { "compiler.misc.ccf.unrecognized.attribute", "{0}は認識されない属性です" }, { "compiler.misc.clashes.with", "{1}の{0}は{3}の{2}と競合します" }, { "compiler.misc.class.file.not.found", "{0}のクラス・ファイルが見つかりません" }, { "compiler.misc.class.file.wrong.class", "クラス・ファイル{0}に不正なクラスがあります" }, { "compiler.misc.conditional.target.cant.be.void", "条件式のターゲット型はvoidにできません" }, { "compiler.misc.count.error", "エラー{0}個" }, { "compiler.misc.count.error.plural", "エラー{0}個" }, { "compiler.misc.count.warn", "警告{0}個" }, { "compiler.misc.count.warn.plural", "警告{0}個" }, { "compiler.misc.descriptor", "ディスクリプタ: {2} {0}({1})" }, { "compiler.misc.descriptor.throws", "ディスクリプタ: {2} {0}({1})で{3}がスローされます" }, { "compiler.misc.diamond", "{0}<>" }, { "compiler.misc.diamond.and.anon.class", "匿名内部クラスでは''<>''を使用できません" }, { "compiler.misc.diamond.and.explicit.params", "コンストラクタの明示的な型パラメータでは''<>''を使用できません" }, { "compiler.misc.diamond.non.generic", "非汎用クラス{0}で''<>''を使用することはできません" }, { "compiler.misc.explicit.param.do.not.conform.to.bounds", "明示的な型引数{0}は、宣言された境界{1}に適合しません" }, { "compiler.misc.fatal.err.cant.close", "致命的エラー: コンパイラ・リソースを閉じることができません" }, { "compiler.misc.fatal.err.cant.locate.ctor", "致命的エラー: {0}のコンストラクタを検出できません" }, { "compiler.misc.fatal.err.cant.locate.field", "致命的エラー: フィールド{0}を検出できません" }, { "compiler.misc.fatal.err.cant.locate.meth", "致命的エラー: メソッド{0}を検出できません" }, { "compiler.misc.fatal.err.no.java.lang", "致命的エラー: クラスパスまたはブート・クラスパスでパッケージjava.langを検出できません" }, { "compiler.misc.file.does.not.contain.package", "ファイルにパッケージ{0}が含まれていません" }, { "compiler.misc.file.doesnt.contain.class", "ファイルにクラス{0}が含まれていません" }, { "compiler.misc.illegal.start.of.class.file", "クラス・ファイルの開始が不正です" }, { "compiler.misc.inaccessible.varargs.type", "仮可変引数要素型{0}は{1} {2}からアクセスできません" }, { "compiler.misc.inapplicable.method", "{0} {1}.{2}は使用できません\n({3})" }, { "compiler.misc.incompatible.abstracts", "{0} {1}で複数のオーバーライドしない抽象メソッドが見つかりました" }, { "compiler.misc.incompatible.arg.types.in.lambda", "ラムダ式のパラメータ型は不適合です" }, { "compiler.misc.incompatible.arg.types.in.mref", "メソッド参照のパラメータ型は不適合です" }, { "compiler.misc.incompatible.descs.in.functional.intf", "{0} {1}で不適合な機能ディスクリプタが見つかりました" }, { "compiler.misc.incompatible.eq.lower.bounds", "推論変数{0}には、不適合な境界があります\n等価制約: {1}\n下限: {2}" }, { "compiler.misc.incompatible.eq.upper.bounds", "推論変数{0}には、不適合な境界があります\n等価制約: {1}\n上限: {2}" }, { "compiler.misc.incompatible.ret.type.in.lambda", "ラムダ式の戻り型が不正です\n{0}" }, { "compiler.misc.incompatible.ret.type.in.mref", "メソッド参照の戻り型が不正です\n{0}" }, { "compiler.misc.incompatible.type.in.conditional", "条件式の型が不正です\n{0}" }, { "compiler.misc.incompatible.upper.bounds", "推論変数{0}には、不適合な上限{1}があります" }, { "compiler.misc.inconvertible.types", "{0}を{1}に変換できません:" }, { "compiler.misc.infer.arg.length.mismatch", "型変数{0}を推論できません\n(実引数リストと仮引数リストの長さが異なります)" }, { "compiler.misc.infer.no.conforming.assignment.exists", "型変数{0}を推論できません\n(引数の不一致: {1})" }, { "compiler.misc.infer.no.conforming.instance.exists", "型変数{0}のインスタンスが存在しないので、{1}は{2}に適合しません" }, { "compiler.misc.infer.varargs.argument.mismatch", "型変数{0}を推論できません\n(可変引数の不一致: {1})" }, { "compiler.misc.inferred.do.not.conform.to.eq.bounds", "推論型が等価制約に適合しません\n推論: {0}\n等価制約: {1}" }, { "compiler.misc.inferred.do.not.conform.to.lower.bounds", "推論型が下限に適合しません\n推論: {0}\n下限: {1}" }, { "compiler.misc.inferred.do.not.conform.to.upper.bounds", "推論型が上限に適合しません\n推論: {0}\n上限: {1}" }, { "compiler.misc.inner.cls", "内部クラス" }, { "compiler.misc.intersection.type", "INT#{0}" }, { "compiler.misc.invalid.default.interface", "バージョン{0}.{1}のクラス・ファイルにデフォルト・メソッドが見つかりました" }, { "compiler.misc.invalid.generic.lambda.target", "ラムダ式の機能ディスクリプタが無効です\n{1} {2}のメソッド{0}は汎用です" }, { "compiler.misc.invalid.mref", "{0}参照が無効です\n{1}" }, { "compiler.misc.invalid.static.interface", "バージョン{0}.{1}のクラス・ファイルにstaticメソッドが見つかりました" }, { "compiler.misc.kindname.annotation", "@interface" }, { "compiler.misc.kindname.class", "クラス" }, { "compiler.misc.kindname.constructor", "コンストラクタ" }, { "compiler.misc.kindname.enum", "列挙" }, { "compiler.misc.kindname.instance.init", "インスタンス初期化子" }, { "compiler.misc.kindname.interface", "インタフェース" }, { "compiler.misc.kindname.method", "メソッド" }, { "compiler.misc.kindname.package", "パッケージ" }, { "compiler.misc.kindname.static", "static" }, { "compiler.misc.kindname.static.init", "static初期化子" }, { "compiler.misc.kindname.type.variable", "型変数" }, { "compiler.misc.kindname.type.variable.bound", "型変数の境界" }, { "compiler.misc.kindname.value", "値" }, { "compiler.misc.kindname.variable", "変数" }, { "compiler.misc.lambda", "ラムダ式" }, { "compiler.misc.location", "{0} {1}" }, { "compiler.misc.location.1", "タイプ{2}の{0} {1}" }, { "compiler.misc.missing.ret.val", "戻り値がありません" }, { "compiler.misc.mref.infer.and.explicit.params", "コンストラクタの明示的な型パラメータではrawコンストラクタ参照を使用できません" }, { "compiler.misc.no.abstracts", "{0} {1}で抽象メソッドが見つかりません" }, { "compiler.misc.no.args", "引数がありません" }, { "compiler.misc.no.conforming.assignment.exists", "引数の不一致: {0}" }, { "compiler.misc.no.suitable.functional.intf.inst", "{0}の機能インタフェース・ディスクリプタを推論できません" }, { "compiler.misc.no.unique.maximal.instance.exists", "型変数{0}(上限{1})の固有の最大インスタンスが存在しません" }, { "compiler.misc.no.unique.minimal.instance.exists", "型変数{0}(下限{1})の固有の最小インスタンスが存在しません" }, { "compiler.misc.non-static.cant.be.ref", "staticでない{0} {1}をstaticコンテキストから参照することはできません" }, { "compiler.misc.not.a.functional.intf", "{0}は機能インタフェースではありません" }, { "compiler.misc.not.a.functional.intf.1", "{0}は機能インタフェースではありません\n{1}" }, { "compiler.misc.not.an.intf.component", "コンポーネント・タイプ{0}はインタフェースではありません" }, { "compiler.misc.not.applicable.method.found", "#{0}個の使用できないメソッドが見つかりました: {1}\n({2})" }, { "compiler.misc.not.def.access.class.intf.cant.access", "{1}の{0}がアクセスできないクラスまたはインタフェースに定義されています" }, { "compiler.misc.not.def.public.cant.access", "{1}の{0}はpublicではありません。パッケージ外からはアクセスできません" }, { "compiler.misc.overridden.default", "{1}のメソッド{0}はオーバーライドされます" }, { "compiler.misc.partial.inst.sig", "部分的にインスタンス化されました: {0}" }, { "compiler.misc.possible.loss.of.precision", "精度が失われる可能性がある{0}から{1}への変換" }, { "compiler.misc.prob.found.req", "不適合な型: {0}" }, { "compiler.misc.redundant.supertype", "冗長なインタフェース{0}は{1}によって拡張されました" }, { "compiler.misc.ref.ambiguous", "{0}の参照はあいまいです\n{3}の{1} {2}と{6}の{4} {5}の両方が一致します" }, { "compiler.misc.report.access", "{0}は{2}で{1}アクセスされます" }, { "compiler.misc.resume.abort", "R)再開,A)中止>" }, { "compiler.misc.source.unavailable", "(ソースが利用不可)" }, { "compiler.misc.static.bound.mref", "staticのバインディングされたメソッド参照" }, { "compiler.misc.static.method.in.unbound.lookup", "非バインド検索で静的な{0} {1}が見つかりました" }, { "compiler.misc.static.mref.with.targs", "staticメソッド参照のパラメータ化された修飾子" }, { "compiler.misc.token.bad-symbol", "<bad symbol>" }, { "compiler.misc.token.character", "<character>" }, { "compiler.misc.token.double", "<double>" }, { "compiler.misc.token.end-of-input", "<end of input>" }, { "compiler.misc.token.float", "<float>" }, { "compiler.misc.token.identifier", "<identifier>" }, { "compiler.misc.token.integer", "<integer>" }, { "compiler.misc.token.long-integer", "<long integer>" }, { "compiler.misc.token.string", "<string>" }, { "compiler.misc.try.not.applicable.to.type", "try-with-resourceは変数型に使用できません\n({0})" }, { "compiler.misc.type.captureof", "{1}のキャプチャ#{0}" }, { "compiler.misc.type.captureof.1", "キャプチャ#{0}" }, { "compiler.misc.type.none", "<none>" }, { "compiler.misc.type.null", "<null>" }, { "compiler.misc.type.parameter", "型パラメータ{0}" }, { "compiler.misc.type.req.array.or.iterable", "配列またはjava.lang.Iterable" }, { "compiler.misc.type.req.class", "クラス" }, { "compiler.misc.type.req.class.array", "クラスまたは配列" }, { "compiler.misc.type.req.exact", "境界のないクラスまたはインタフェース" }, { "compiler.misc.type.req.ref", "参照" }, { "compiler.misc.type.var", "{0}#{1}" }, { "compiler.misc.unable.to.access.file", "ファイル{0}にアクセスできません" }, { "compiler.misc.unchecked.assign", "無検査変換" }, { "compiler.misc.unchecked.cast.to.type", "無検査キャスト" }, { "compiler.misc.unchecked.clash.with", "{1}の{0}は{3}の{2}をオーバーライドします" }, { "compiler.misc.unchecked.implement", "{1}の{0}は{3}の{2}を実装します" }, { "compiler.misc.unchecked.override", "{1}の{0}は{3}の{2}をオーバーライドします" }, { "compiler.misc.undecl.type.var", "型変数{0}は宣言されていません" }, { "compiler.misc.unexpected.ret.val", "予期しない戻り値" }, { "compiler.misc.unicode.str.not.supported", "クラス・ファイル内のUnicode文字列はサポートされていません" }, { "compiler.misc.unnamed.package", "名前のないパッケージ" }, { "compiler.misc.varargs.argument.mismatch", "可変引数の不一致: {0}" }, { "compiler.misc.varargs.clash.with", "{1}の{0}は{3}の{2}をオーバーライドします" }, { "compiler.misc.varargs.implement", "{1}の{0}は{3}の{2}を実装します" }, { "compiler.misc.varargs.override", "{1}の{0}は{3}の{2}をオーバーライドします" }, { "compiler.misc.varargs.trustme.on.non.varargs.meth", "メソッド{0}は可変引数メソッドではありません。" }, { "compiler.misc.varargs.trustme.on.reifiable.varargs", "可変引数要素型{0}はreifiable型です。" }, { "compiler.misc.varargs.trustme.on.virtual.varargs", "インスタンス・メソッド{0}はfinalではありません。" }, { "compiler.misc.verbose.checking.attribution", "[{0}を確認中]" }, { "compiler.misc.verbose.classpath", "[クラス・ファイルの検索パス: {0}]" }, { "compiler.misc.verbose.loading", "[{0}を読込み中]" }, { "compiler.misc.verbose.parsing.done", "[{0}ミリ秒で構文解析完了]" }, { "compiler.misc.verbose.parsing.started", "[{0}を構文解析開始]" }, { "compiler.misc.verbose.retro", "[{0}を組替え中]" }, { "compiler.misc.verbose.retro.with", "\t{0}を{1}で組替え中です" }, { "compiler.misc.verbose.retro.with.list", "\t{0}を型パラメータ{1}、スーパータイプ{2}、インタフェース{3}で組替え中です" }, { "compiler.misc.verbose.sourcepath", "[ソース・ファイルの検索パス: {0}]" }, { "compiler.misc.verbose.total", "[合計{0}ミリ秒]" }, { "compiler.misc.verbose.wrote.file", "[{0}を書込み完了]" }, { "compiler.misc.version.not.available", "(バージョン情報がありません)" }, { "compiler.misc.where.captured", "{0}は{3}のキャプチャから{1}を拡張し{2}をスーパーします" }, { "compiler.misc.where.captured.1", "{0}は{3}のキャプチャから{1}を拡張します" }, { "compiler.misc.where.description.captured", "{0}が新しい型変数の場合:" }, { "compiler.misc.where.description.captured.1", "{0}が新しい型変数の場合:" }, { "compiler.misc.where.description.intersection", "{0}がintersection型の場合:" }, { "compiler.misc.where.description.intersection.1", "{0}がintersection型の場合:" }, { "compiler.misc.where.description.typevar", "{0}が型変数の場合:" }, { "compiler.misc.where.description.typevar.1", "{0}が型変数の場合:" }, { "compiler.misc.where.fresh.typevar", "{0}は{1}を拡張します" }, { "compiler.misc.where.intersection", "{0}は{1}を拡張します" }, { "compiler.misc.where.typevar", "{2} {3}で宣言されている{0}は{1}を拡張します" }, { "compiler.misc.where.typevar.1", "{2} {3}で宣言された{0}" }, { "compiler.misc.wrong.version", "クラス・ファイルのバージョン{0}.{1}は不正です。{2}.{3}である必要があります" }, { "compiler.misc.x.print.processor.info", "プロセッサ{0}は{1}に一致し、{2}を返します。" }, { "compiler.misc.x.print.rounds", "往復{0}:\n\t入力ファイル: {1}\n\t注釈: {2}\n\t最後の往復: {3}" }, { "compiler.note.compressed.diags", "一部のメッセージは簡略化されています。-Xdiags:verboseで再コンパイルして完全な出力を取得してください" }, { "compiler.note.deferred.method.inst", "メソッド{0}の遅延インスタンス化\nインスタンス化されたシグネチャ: {1}\nターゲット型: {2}" }, { "compiler.note.deprecated.filename", "{0}は非推奨のAPIを使用またはオーバーライドしています。" }, { "compiler.note.deprecated.filename.additional", "{0}に非推奨のAPIの追加使用またはオーバーライドがあります。" }, { "compiler.note.deprecated.plural", "一部の入力ファイルは非推奨のAPIを使用またはオーバーライドしています。" }, { "compiler.note.deprecated.plural.additional", "一部の入力ファイルは非推奨のAPIを追加使用またはオーバーライドしています。" }, { "compiler.note.deprecated.recompile", "詳細は、-Xlint:deprecationオプションを指定して再コンパイルしてください。" }, { "compiler.note.lambda.stat", "ラムダ式を変換しています\n代替metafactory = {0}\n合成メソッド = {1}" }, { "compiler.note.mref.stat", "メソッド参照を変換しています\n代替metafactory = {0}\n" }, { "compiler.note.mref.stat.1", "メソッド参照を変換しています\n代替metafactory = {0}\nブリッジ・メソッド = {1}" }, { "compiler.note.note", "注意:" }, { "compiler.note.potential.lambda.found", "この匿名内部クラスをラムダ式に変換できます。" }, { "compiler.note.proc.messager", "{0}" }, { "compiler.note.sunapi.filename", "{0}は、今後のリリースで削除される可能性がある内部所有のAPIを使用しています。" }, { "compiler.note.sunapi.filename.additional", "{0}は、今後のリリースで削除される可能性がある追加の内部所有のAPIを使用しています。" }, { "compiler.note.sunapi.plural", "一部の入力ファイルは、今後のリリースで削除される可能性がある内部所有のAPIを使用しています。" }, { "compiler.note.sunapi.plural.additional", "一部の入力ファイルは、今後のリリースで削除される可能性がある内部所有のAPIを追加で使用しています。" }, { "compiler.note.sunapi.recompile", "詳細は、-Xlint:sunapiオプションを指定して再コンパイルしてください。" }, { "compiler.note.unchecked.filename", "{0}の操作は、未チェックまたは安全ではありません。" }, { "compiler.note.unchecked.filename.additional", "{0}に未チェックまたは安全ではない操作がさらにあります。" }, { "compiler.note.unchecked.plural", "入力ファイルの操作のうち、未チェックまたは安全ではないものがあります。" }, { "compiler.note.unchecked.plural.additional", "入力ファイルの操作のうち、未チェックまたは安全ではないものがさらにあります。" }, { "compiler.note.unchecked.recompile", "詳細は、-Xlint:uncheckedオプションを指定して再コンパイルしてください。" }, { "compiler.note.verbose.resolve.multi", "型{1}のメソッド{0}を候補{2}に解決しています\nフェーズ: {3}\n実際の型: {4}\n型引数: {5}\n候補:" }, { "compiler.note.verbose.resolve.multi.1", "型{1}のメソッド{0}の解決にエラーがあります\nフェーズ: {3}\n実際の型: {4}\n型引数: {5}\n候補:" }, { "compiler.warn.access.to.sensitive.member.from.serializable.element", "直列化可能要素から機密メンバー{0}へのアクセスは、信頼できないコードからパブリックにアクセス可能である可能性があります" }, { "compiler.warn.annotation.method.not.found", "タイプ''{0}''内に注釈メソッド''{1}()''が見つかりません" }, { "compiler.warn.annotation.method.not.found.reason", "タイプ''{0}''内に注釈メソッド''{1}()''が見つかりません: {2}" }, { "compiler.warn.assert.as.identifier", "リリース1.4から''assert''はキーワードなので、識別子として使用することはできません\n(''assert''をキーワードとして使用するには、-source 1.4以降を使用してください)" }, { "compiler.warn.auxiliary.class.accessed.from.outside.of.its.source.file", "{1}の補助クラス{0}にソース・ファイル外からアクセスできません" }, { "compiler.warn.big.major.version", "{0}: メジャー・バージョン{1}は、このコンパイラでサポートされている最新のメジャー・バージョン{2}より新しいです。\nコンパイラのアップグレードをお薦めします。" }, { "compiler.warn.constant.SVUID", "serialVersionUIDはクラス{0}の定数である必要があります" }, { "compiler.warn.diamond.redundant.args", "新しい式の型引数が重複しています(かわりにダイヤモンド演算子を使用します)。" }, { "compiler.warn.diamond.redundant.args.1", "新しい式の型引数が重複しています(かわりにダイヤモンド演算子を使用します)。\n明示的: {0}\n推論: {1}" }, { "compiler.warn.dir.path.element.not.found", "不正なパス要素\"{0}\": そのディレクトリは存在しません" }, { "compiler.warn.div.zero", "ゼロで除算" }, { "compiler.warn.empty.if", "if以降が空の文です" }, { "compiler.warn.enum.as.identifier", "リリース5から''enum''はキーワードなので識別子として使用することはできません\n(''enum''をキーワードとして使用するには-source 5以降を使用してください)" }, { "compiler.warn.finally.cannot.complete", "finally節が正常に完了できません" }, { "compiler.warn.forward.ref", "初期化される前の変数''{0}''を参照しようとしました" }, { "compiler.warn.future.attr", "バージョン{1}.{2}のクラス・ファイルで導入された{0}属性は、バージョン{3}.{4}のクラス・ファイルでは無視されます" }, { "compiler.warn.has.been.deprecated", "{1}の{0}は非推奨になりました" }, { "compiler.warn.illegal.char.for.encoding", "この文字は、エンコーディング{0}にマップできません" }, { "compiler.warn.improper.SVUID", "serialVersionUIDは、クラス{0}にstatic finalを宣言する必要があります" }, { "compiler.warn.inexact.non-varargs.call", "最終パラメータの不正確な引数型を持った可変引数メソッドの非可変引数呼出し。\n可変引数呼出しに関しては{0}にキャストします。\n非可変引数呼出しに関しては{1}にキャストしてこの警告を出さないようにします" }, { "compiler.warn.invalid.archive.file", "パス上の予期しないファイル: {0}" }, { "compiler.warn.lintOption", "[{0}] " }, { "compiler.warn.long.SVUID", "serialVersionUIDは、クラス{0}のlong型である必要があります" }, { "compiler.warn.missing.SVUID", "直列化可能なクラス{0}には、serialVersionUIDが定義されていません" }, { "compiler.warn.missing.deprecated.annotation", "非推奨の項目は@Deprecatedで注釈が付けられていません" }, { "compiler.warn.option.obsolete.source", "ソース値{0}は廃止されていて、今後のリリースで削除される予定です" }, { "compiler.warn.option.obsolete.suppression", "廃止されたオプションについての警告を表示しないようにするには、-Xlint:オプションを使用します。" }, { "compiler.warn.option.obsolete.target", "ターゲット値{0}は廃止されていて、今後のリリースで削除される予定です" }, { "compiler.warn.override.bridge", "{0}。オーバーライドされたメソッドはブリッジ・メソッドです" }, { "compiler.warn.override.equals.but.not.hashcode", "クラス{0}はequalsをオーバーライドしますが、このクラスも、また、いかなるスーパークラスも、hashCodeメソッドをオーバーライドしません" }, { "compiler.warn.override.unchecked.ret", "{0}\n戻り値の型は{1}から{2}への無検査変換が必要です" }, { "compiler.warn.override.unchecked.thrown", "{0}\nオーバーライドされたメソッドは{1}をスローしません" }, { "compiler.warn.override.varargs.extra", "{0}。オーバーライドしているメソッドには''...''がありません" }, { "compiler.warn.override.varargs.missing", "{0}。オーバーライドされたメソッドには''...''がありません" }, { "compiler.warn.path.element.not.found", "不正なパス要素\"{0}\": そのファイルまたはディレクトリはありません" }, { "compiler.warn.pkg-info.already.seen", "package-info.javaファイルがすでにパッケージ{0}用に表示されています" }, { "compiler.warn.position.overflow", "位置エンコーディングが行{0}でオーバーフローします" }, { "compiler.warn.possible.fall-through.into.case", "caseにfall-throughする可能性があります" }, { "compiler.warn.potentially.ambiguous.overload", "{1}内の{0}は{3}内の{2}と矛盾する可能性があります" }, { "compiler.warn.prob.found.req", "{0}\n期待値: {2}\n検出値:    {1}" }, { "compiler.warn.proc.annotations.without.processors", "これらの注釈を要求するプロセッサはありませんでした: {0}" }, { "compiler.warn.proc.file.create.last.round", "最後に作成されたタイプ''{0}''のファイルは注釈処理に渡されません。" }, { "compiler.warn.proc.file.reopening", "''{0}''用のファイルを複数回作成しようとしています" }, { "compiler.warn.proc.illegal.file.name", "無効な名前''{0}''のファイルは作成できません。" }, { "compiler.warn.proc.malformed.supported.string", "プロセッサ''{1}''が返したサポートされる注釈型の文字列''{0}''が不正です" }, { "compiler.warn.proc.messager", "{0}" }, { "compiler.warn.proc.package.does.not.exist", "パッケージ{0}は存在しません" }, { "compiler.warn.proc.proc-only.requested.no.procs", "コンパイルなしの注釈処理がリクエストされましたが、プロセッサが見つかりませんでした。" }, { "compiler.warn.proc.processor.incompatible.source.version", "注釈プロセッサ''{1}''から-source ''{2}''より小さいソース・バージョン''{0}''がサポートされています" }, { "compiler.warn.proc.suspicious.class.name", "名前が{1}で終わる型のファイルを作成しています: ''{0}''" }, { "compiler.warn.proc.type.already.exists", "タイプ''{0}''のファイルはすでにソース・パスまたはクラスパスに存在します" }, { "compiler.warn.proc.type.recreate", "タイプ''{0}''のファイルを複数回作成しようとしています" }, { "compiler.warn.proc.unclosed.type.files", "タイプ''{0}''のファイルが閉じられていません。これらのタイプは注釈処理されません" }, { "compiler.warn.proc.unmatched.processor.options", "次のオプションはどのプロセッサでも認識されませんでした: ''{0}''" }, { "compiler.warn.proc.use.implicit", "暗黙的にコンパイルされたファイルは注釈処理に渡されません。\n-implicitを使用し暗黙的コンパイルのポリシーを指定してください。" }, { "compiler.warn.proc.use.proc.or.implicit", "暗黙的にコンパイルされたファイルは注釈処理に渡されません。\n-proc:noneを使用し注釈処理を無効にするか -implicitを使用し暗黙的コンパイルのポリシーを指定してください。" }, { "compiler.warn.raw.class.use", "raw型が見つかりました: {0}\n汎用クラス{1}の型引数がありません" }, { "compiler.warn.redundant.cast", "{0}への冗長なキャストです" }, { "compiler.warn.self.ref", "初期化子内の変数''{0}''の自己参照" }, { "compiler.warn.source.no.bootclasspath", "ブートストラップ・クラスパスが-source {0}と一緒に設定されていません" }, { "compiler.warn.static.not.qualified.by.type", "static {0}は式ではなく型名{1}で修飾する必要があります" }, { "compiler.warn.sun.proprietary", "{0}は内部所有のAPIであり、今後のリリースで削除される可能性があります" }, { "compiler.warn.synthetic.name.conflict", "シンボル{0}が、{1}でコンパイラが合成したシンボルと競合します" }, { "compiler.warn.try.explicit.close.call", "自動クローズ可能なリソースにおけるclose()の明示的呼出し" }, { "compiler.warn.try.resource.not.referenced", "自動クローズ可能なリソース{0}は対応するtry文の本体では参照されません" }, { "compiler.warn.try.resource.throws.interrupted.exc", "自動クローズ可能なリソース{0}に、InterruptedExceptionをスローする可能性があるメンバー・メソッドclose()があります" }, { "compiler.warn.unchecked.assign", "{0}から{1}への無検査代入です" }, { "compiler.warn.unchecked.assign.to.var", "raw型{1}のメンバーとして変数{0}への無検査代入です" }, { "compiler.warn.unchecked.call.mbr.of.raw.type", "raw型{1}のメンバーとしての{0}への無検査呼出しです" }, { "compiler.warn.unchecked.cast.to.type", "型{0}への無検査キャストです" }, { "compiler.warn.unchecked.generic.array.creation", "型{0}の可変引数パラメータに対する総称型配列の無検査作成です" }, { "compiler.warn.unchecked.meth.invocation.applied", "無検査メソッド呼出し: {4} {5}の{0} {1}は指定された型に適用されます\n期待値: {2}\n検出値: {3}" }, { "compiler.warn.unchecked.varargs.non.reifiable.type", "パラメータ化された可変引数型{0}からのヒープ汚染の可能性があります" }, { "compiler.warn.underscore.as.identifier", "識別子として''_''が使用されました\n(識別子としての''_''の使用は、Java SE 8より後のリリースではサポートされない可能性があります)" }, { "compiler.warn.unexpected.archive.file", "アーカイブ・ファイルの予期しない拡張子: {0}" }, { "compiler.warn.unknown.enum.constant", "不明な列挙型定数です{1}.{2}" }, { "compiler.warn.unknown.enum.constant.reason", "不明な列挙型定数です{1}.{2}\n理由: {3}" }, { "compiler.warn.unreachable.catch", "catch句に移すことができません\nスローされたタイプ{0}はすでに捕捉されています" }, { "compiler.warn.unreachable.catch.1", "catch句に移すことができません\nスローされたタイプ{0}はすでに捕捉されています" }, { "compiler.warn.varargs.redundant.trustme.anno", "{0}注釈が冗長です。{1}" }, { "compiler.warn.varargs.unsafe.use.varargs.param", "可変引数メソッドは、型情報保持可能でない可変引数パラメータ{0}からのヒープ汚染の原因となる可能性があります" }, { "compiler.warn.warning", "警告: " } };
/*   */   }
/*   */ }


/* Location:              C:\Program Files\Java\jdk1.8.0_211\lib\tools.jar!\com\sun\tools\javac\resources\compiler_ja.class
 * Java compiler version: 8 (52.0)
 * JD-Core Version:       1.1.3
 */