/*    */ package com.sun.tools.example.debug.tty;
/*    */ 
/*    */ import java.util.ListResourceBundle;
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ 
/*    */ public class TTYResources_zh_CN
/*    */   extends ListResourceBundle
/*    */ {
/*    */   public Object[][] getContents() {
/* 58 */     return new Object[][] { { "** classes list **", "** 类列表 **\n{0}" }, { "** fields list **", "** 字段列表 **\n{0}" }, { "** methods list **", "** 方法列表 **\n{0}" }, { "*** Reading commands from", "*** 正在从{0}读取命令" }, { "All threads resumed.", "已恢复所有线程。" }, { "All threads suspended.", "已挂起所有线程。" }, { "Argument is not defined for connector:", "没有为连接器{1}定义参数{0}" }, { "Arguments match no method", "参数不与任何方法匹配" }, { "Array:", "数组: {0}" }, { "Array element is not a method", "数组元素不是方法" }, { "Array index must be a integer type", "数组索引必须为整数类型" }, { "base directory:", "基目录: {0}" }, { "bootclasspath:", "引导类路径: {0}" }, { "Breakpoint hit:", "断点命中: " }, { "breakpoint", "断点{0}" }, { "Breakpoints set:", "断点集:" }, { "Breakpoints can be located only in classes.", "断点只能位于类中。{0}是接口或数组。" }, { "Can only trace", "只能跟踪 'methods', 'method exit' 或 'method exits'" }, { "cannot redefine existing connection", "{0}无法重新定义现有连接" }, { "Cannot assign to a method invocation", "无法分配到方法调用" }, { "Cannot specify command line with connector:", "无法指定带有连接器的命令行: {0}" }, { "Cannot specify target vm arguments with connector:", "无法指定带有连接器的目标 VM 参数: {0}" }, { "Class containing field must be specified.", "必须指定包含字段的类。" }, { "Class:", "类: {0}" }, { "Classic VM no longer supported.", "不再支持经典 VM。" }, { "classpath:", "类路径: {0}" }, { "colon mark", ":" }, { "colon space", ": " }, { "Command is not supported on the target VM", "目标 VM 不支持命令 ''{0}''" }, { "Command is not supported on a read-only VM connection", "只读 VM 连接不支持命令 ''{0}''" }, { "Command not valid until the VM is started with the run command", "在使用 ''run'' 命令启动 VM 前, 命令 ''{0}'' 是无效的" }, { "Condition must be boolean", "条件必须是布尔型" }, { "Connector and Transport name", "  连接器: {0}, 传输: {1}" }, { "Connector argument nodefault", "    参数: {0} (无默认值)" }, { "Connector argument default", "    参数: {0}, 默认值: {1}" }, { "Connector description", "    说明: {0}" }, { "Connector required argument nodefault", "    所需的参数: {0} (无默认值)" }, { "Connector required argument default", "    所需的参数: {0}, 默认值: {1}" }, { "Connectors available", "可用连接器为:" }, { "Constant is not a method", "常量不是方法" }, { "Could not open:", "无法打开: {0}" }, { "Current method is native", "当前方法为本机方法" }, { "Current thread died. Execution continuing...", "当前线程{0}已成为死线程。继续执行..." }, { "Current thread isnt suspended.", "当前线程未挂起。" }, { "Current thread not set.", "当前线程未设置。" }, { "dbgtrace flag value must be an integer:", "dbgtrace 标记值必须为整数: {0}" }, { "Deferring.", "正在延迟{0}。\n将在加载类后设置。" }, { "End of stack.", "堆栈结束。" }, { "Error popping frame", "使帧出栈时出错 - {0}" }, { "Error reading file", "读取 ''{0}'' 时出错 - {1}" }, { "Error redefining class to file", "将{0}重新定义为{1}时出错 - {2}" }, { "exceptionSpec all", "所有{0}" }, { "exceptionSpec caught", "捕获的{0}" }, { "exceptionSpec uncaught", "未捕获的{0}" }, { "Exception in expression:", "表达式中出现异常错误: {0}" }, { "Exception occurred caught", "出现异常错误: {0} (将在以下位置捕获: {1})" }, { "Exception occurred uncaught", "出现异常错误: {0} (未捕获)" }, { "Exceptions caught:", "出现这些异常错误时中断:" }, { "expr is null", "{0} = 空值" }, { "expr is value", "{0} = {1}" }, { "expr is value <collected>", "  {0} = {1} <已收集>" }, { "Expression cannot be void", "表达式不能为空" }, { "Expression must evaluate to an object", "表达式的计算结果必须为对象" }, { "extends:", "扩展: {0}" }, { "Failed reading output", "无法读取子 Java 解释器的输出。" }, { "Fatal error", "致命错误:" }, { "Field access encountered before after", "字段 ({0}) 为{1}, 将为{2}: " }, { "Field access encountered", "遇到字段 ({0}) 访问: " }, { "Field to unwatch not specified", "未指定要取消监视的字段。" }, { "Field to watch not specified", "未指定要监视的字段。" }, { "GC Disabled for", "已对{0}禁用 GC:" }, { "GC Enabled for", "已对{0}启用 GC:" }, { "grouping begin character", "{" }, { "grouping end character", "}" }, { "Illegal Argument Exception", "非法参数异常错误" }, { "Illegal connector argument", "非法连接器参数: {0}" }, { "implementor:", "实现者: {0}" }, { "implements:", "实现: {0}" }, { "Initializing progname", "正在初始化{0}..." }, { "Input stream closed.", "输入流已关闭。" }, { "Interface:", "接口: {0}" }, { "Internal debugger error.", "内部调试器错误。" }, { "Internal error: null ThreadInfo created", "内部错误: 创建了空值 ThreadInfo" }, { "Internal error; unable to set", "内部错误; 无法设置{0}" }, { "Internal exception during operation:", "操作期间出现内部异常错误:\n    {0}" }, { "Internal exception:", "内部异常错误:" }, { "Invalid argument type name", "参数类型名称无效" }, { "Invalid assignment syntax", "赋值语法无效" }, { "Invalid command syntax", "命令语法无效" }, { "Invalid connect type", "连接类型无效" }, { "Invalid consecutive invocations", "连续调用无效" }, { "Invalid exception object", "异常错误对象无效" }, { "Invalid method specification:", "方法规范无效: {0}" }, { "Invalid option on class command", "类命令的选项无效" }, { "invalid option", "选项无效: {0}" }, { "Invalid thread status.", "线程状态无效。" }, { "Invalid transport name:", "传输名称无效: {0}" }, { "I/O exception occurred:", "出现 I/O 异常错误: {0}" }, { "is an ambiguous method name in", "\"{0}\" 在 \"{1}\" 中是不明确的方法名称" }, { "is an invalid line number for", "{0,number,integer} 是{1}的无效行号" }, { "is not a valid class name", "\"{0}\" 不是有效的类名。" }, { "is not a valid field name", "\"{0}\" 不是有效的字段名。" }, { "is not a valid id or class name", "\"{0}\" 不是有效的 ID 或类名。" }, { "is not a valid line number or method name for", "\"{0}\" 不是类 \"{1}\" 的有效行号或方法名" }, { "is not a valid method name", "\"{0}\" 不是有效的方法名。" }, { "is not a valid thread id", "\"{0}\" 不是有效的线程 ID。" }, { "is not a valid threadgroup name", "\"{0}\" 不是有效的线程组名称。" }, { "jdb prompt with no current thread", "> " }, { "jdb prompt thread name and current stack frame", "{0}[{1,number,integer}] " }, { "killed", "{0}已终止" }, { "killing thread:", "正在终止线程: {0}" }, { "Line number information not available for", "此位置的源行号不可用。" }, { "line number", ":{0,number,integer}" }, { "list field typename and name", "{0} {1}\n" }, { "list field typename and name inherited", "{0} {1} (继承自{2})\n" }, { "list field typename and name hidden", "{0} {1} (隐藏)\n" }, { "Listening at address:", "监听地址: {0}" }, { "Local variable information not available.", "本地变量信息不可用。请使用 -g 编译以生成变量信息" }, { "Local variables:", "本地变量:" }, { "<location unavailable>", "<位置不可用>" }, { "location", "\"线程={0}\", {1}" }, { "locationString", "{0}.{1}(), 行={2,number,integer} bci={3,number,integer}" }, { "Main class and arguments must be specified", "必须指定主类和参数" }, { "Method arguments:", "方法参数:" }, { "Method entered:", "已进入方法: " }, { "Method exited:", "已退出方法" }, { "Method exitedValue:", "已退出方法: 返回值 = {0}, " }, { "Method is overloaded; specify arguments", "已重载方法{0}; 请指定参数" }, { "minus version", "这是{0}版本 {1,number,integer}.{2,number,integer} (Java SE 版本 {3})" }, { "Monitor information for thread", "监视线程{0}的信息:" }, { "Monitor information for expr", "监视{0} ({1}) 的信息:" }, { "More than one class named", "多个类的名称为: ''{0}''" }, { "native method", "本机方法" }, { "nested:", "嵌套: {0}" }, { "No attach address specified.", "未指定附加地址。" }, { "No breakpoints set.", "未设置断点。" }, { "No class named", "没有名为 ''{0}'' 的类" }, { "No class specified.", "未指定类。" }, { "No classpath specified.", "未指定类路径。" }, { "No code at line", "{1}中的行 {0,number,integer} 处没有代码" }, { "No connect specification.", "没有连接规范。" }, { "No connector named:", "没有名为{0}的连接器" }, { "No current thread", "没有当前线程" }, { "No default thread specified:", "未指定默认线程: 请先使用 \"thread\" 命令。" }, { "No exception object specified.", "未指定异常错误对象。" }, { "No exceptions caught.", "未捕获到异常错误。" }, { "No expression specified.", "未指定表达式。" }, { "No field in", "{1}中没有字段{0}" }, { "No frames on the current call stack", "当前调用堆栈上没有帧" }, { "No linenumber information for", "{0}没有行号信息。请尝试在启用调试的情况下编译。" }, { "No local variables", "没有本地变量" }, { "No method in", "{1}中没有方法{0}" }, { "No method specified.", "未指定方法。" }, { "No monitor numbered:", "没有编号为 {0} 的监视器" }, { "No monitors owned", "  不拥有监视器" }, { "No object specified.", "未指定对象。" }, { "No objects specified.", "未指定对象。" }, { "No save index specified.", "未指定保存索引。" }, { "No saved values", "没有保存的值" }, { "No source information available for:", "没有可用于{0}的源信息" }, { "No sourcedebugextension specified", "未指定 SourceDebugExtension" }, { "No sourcepath specified.", "未指定源路径。" }, { "No thread specified.", "未指定线程。" }, { "No VM connected", "未连接 VM" }, { "No waiters", "  没有等待进程" }, { "not a class", "{0}不是类" }, { "Not a monitor number:", "不是监视器编号: ''{0}''" }, { "not found (try the full name)", "找不到{0} (请尝试使用全名)" }, { "Not found:", "找不到: {0}" }, { "not found", "找不到{0}" }, { "Not owned", "  不拥有" }, { "Not waiting for a monitor", "  未等待监视器" }, { "Nothing suspended.", "未挂起任何对象。" }, { "object description and hex id", "({0}){1}" }, { "Operation is not supported on the target VM", "目标 VM 不支持该操作" }, { "operation not yet supported", "尚不支持该操作" }, { "Owned by:", "  拥有者: {0}, 条目计数: {1,number,integer}" }, { "Owned monitor:", "  拥有的监视器: {0}" }, { "Parse exception:", "解析异常错误: {0}" }, { "printbreakpointcommandusage", "用法: {0} <class>:<line_number> 或\n       {1} <class>.<method_name>[(argument_type,...)]" }, { "Removed:", "已删除: {0}" }, { "Requested stack frame is no longer active:", "请求的堆栈帧不再有效: {0,number,integer}" }, { "run <args> command is valid only with launched VMs", "'run <args>' 命令仅对启动的 VM 有效" }, { "run", "运行{0}" }, { "saved", "{0}已保存" }, { "Set deferred", "设置延迟的{0}" }, { "Set", "设置{0}" }, { "Source file not found:", "找不到源文件: {0}" }, { "source line number and line", "{0,number,integer}    {1}" }, { "source line number current line and line", "{0,number,integer} => {1}" }, { "sourcedebugextension", "SourceDebugExtension -- {0}" }, { "Specify class and method", "指定类和方法" }, { "Specify classes to redefine", "指定要重新定义的类" }, { "Specify file name for class", "指定类{0}的文件名" }, { "stack frame dump with pc", "  [{0,number,integer}] {1}.{2} ({3}), pc = {4}" }, { "stack frame dump", "  [{0,number,integer}] {1}.{2} ({3})" }, { "Step completed:", "已完成的步骤: " }, { "Stopping due to deferred breakpoint errors.", "由于延迟断点错误而停止。\n" }, { "subclass:", "子类: {0}" }, { "subinterface:", "子接口: {0}" }, { "tab", "\t{0}" }, { "Target VM failed to initialize.", "无法初始化目标 VM。" }, { "The application exited", "应用程序已退出" }, { "The application has been disconnected", "应用程序已断开连接" }, { "The gc command is no longer necessary.", "不再需要 'gc' 命令。\n所有对象已照常进行垃圾收集。请使用 'enablegc' 和 'disablegc'\n命令来控制各个对象的垃圾收集。" }, { "The load command is no longer supported.", "不再支持 'load' 命令。" }, { "The memory command is no longer supported.", "不再支持 'memory' 命令。" }, { "The VM does not use paths", "VM 不使用路径" }, { "Thread is not running (no stack).", "线程未运行 (没有堆栈)。" }, { "Thread number not specified.", "未指定线程编号。" }, { "Thread:", "{0}:" }, { "Thread Group:", "组{0}:" }, { "Thread description name unknownStatus BP", "  {0} {1}未知 (在断点处)" }, { "Thread description name unknownStatus", "  {0} {1}未知" }, { "Thread description name zombieStatus BP", "  {0} {1}处于僵死状态 (在断点处)" }, { "Thread description name zombieStatus", "  {0} {1}处于僵死状态" }, { "Thread description name runningStatus BP", "  {0} {1}正在运行 (在断点处)" }, { "Thread description name runningStatus", "  {0} {1}正在运行" }, { "Thread description name sleepingStatus BP", "  {0} {1}正在休眠 (在断点处)" }, { "Thread description name sleepingStatus", "  {0} {1}正在休眠" }, { "Thread description name waitingStatus BP", "  {0} {1}正在等待监视器 (在断点处)" }, { "Thread description name waitingStatus", "  {0} {1}正在等待监视器" }, { "Thread description name condWaitstatus BP", "  {0} {1}正在执行条件等待 (在断点处)" }, { "Thread description name condWaitstatus", "  {0} {1}正在执行条件等待" }, { "Thread has been resumed", "已恢复线程" }, { "Thread not suspended", "未挂起线程" }, { "thread group number description name", "{0,number,integer}。{1} {2}" }, { "Threadgroup name not specified.", "未指定线程组名。" }, { "Threads must be suspended", "必须挂起线程" }, { "trace method exit in effect for", "正在对{0}实行 trace method exit" }, { "trace method exits in effect", "正在实行 trace method exits" }, { "trace methods in effect", "正在实行 trace methods" }, { "trace go method exit in effect for", "正在对{0}实行 trace go method exit" }, { "trace go method exits in effect", "正在实行 trace go method exits" }, { "trace go methods in effect", "正在实行 trace go methods" }, { "trace not in effect", "未实行 trace" }, { "Unable to attach to target VM.", "无法附加到目标 VM。" }, { "Unable to display process output:", "无法显示进程输出: {0}" }, { "Unable to launch target VM.", "无法启动目标 VM。" }, { "Unable to set deferred", "无法设置延迟的{0}: {1}" }, { "Unable to set main class and arguments", "无法设置主类和参数" }, { "Unable to set", "无法设置{0}: {1}" }, { "Unexpected event type", "意外的事件类型: {0}" }, { "unknown", "未知" }, { "Unmonitoring", "取消监视{0} " }, { "Unrecognized command.  Try help...", "无法识别的命令: ''{0}''。请尝试获得帮助..." }, { "Usage: catch exception", "用法: catch [uncaught|caught|all] <class id>|<class pattern>" }, { "Usage: ignore exception", "用法: ignore [uncaught|caught|all] <class id>|<class pattern>" }, { "Usage: down [n frames]", "用法: down [n frames]" }, { "Usage: kill <thread id> <throwable>", "用法: kill <thread id> <throwable>" }, { "Usage: read <command-filename>", "用法: read <command-filename>" }, { "Usage: unmonitor <monitor#>", "用法: unmonitor <monitor#>" }, { "Usage: up [n frames]", "用法: up [n frames]" }, { "Use java minus X to see", "使用 'java -X' 可以查看可用的非标准选项" }, { "Use stop at to set a breakpoint at a line number", "使用 'stop at' 可以在行号处设置断点" }, { "VM already running. use cont to continue after events.", "VM 已在运行。请使用 'cont' 以在事件结束后继续。" }, { "VM Started:", "VM 已启动: " }, { "vmstartexception", "VM 启动异常错误: {0}" }, { "Waiting for monitor:", "   正在等待监视器: {0}" }, { "Waiting thread:", " 正在等待线程: {0}" }, { "watch accesses of", "监视{0}.{1}的访问" }, { "watch modification of", "监视{0}.{1}的修改" }, { "zz help text", "** 命令列表 **\nconnectors                -- 列出此 VM 中可用的连接器和传输\n\nrun [class [args]]        -- 开始执行应用程序的主类\n\nthreads [threadgroup]     -- 列出线程\nthread <thread id>        -- 设置默认线程\nsuspend [thread id(s)]    -- 挂起线程 (默认值: all)\nresume [thread id(s)]     -- 恢复线程 (默认值: all)\nwhere [<thread id> | all] -- 转储线程的堆栈\nwherei [<thread id> | all]-- 转储线程的堆栈, 以及 pc 信息\nup [n frames]             -- 上移线程的堆栈\ndown [n frames]           -- 下移线程的堆栈\nkill <thread id> <expr>   -- 终止具有给定的异常错误对象的线程\ninterrupt <thread id>     -- 中断线程\n\nprint <expr>              -- 输出表达式的值\ndump <expr>               -- 输出所有对象信息\neval <expr>               -- 对表达式求值 (与 print 相同)\nset <lvalue> = <expr>     -- 向字段/变量/数组元素分配新值\nlocals                    -- 输出当前堆栈帧中的所有本地变量\n\nclasses                   -- 列出当前已知的类\nclass <class id>          -- 显示已命名类的详细资料\nmethods <class id>        -- 列出类的方法\nfields <class id>         -- 列出类的字段\n\nthreadgroups              -- 列出线程组\nthreadgroup <name>        -- 设置当前线程组\n\nstop in <class id>.<method>[(argument_type,...)]\n                          -- 在方法中设置断点\nstop at <class id>:<line> -- 在行中设置断点\nclear <class id>.<method>[(argument_type,...)]\n                          -- 清除方法中的断点\nclear <class id>:<line>   -- 清除行中的断点\nclear                     -- 列出断点\ncatch [uncaught|caught|all] <class id>|<class pattern>\n                          -- 出现指定的异常错误时中断\nignore [uncaught|caught|all] <class id>|<class pattern>\n                          -- 对于指定的异常错误, 取消 'catch'\nwatch [access|all] <class id>.<field name>\n                          -- 监视对字段的访问/修改\nunwatch [access|all] <class id>.<field name>\n                          -- 停止监视对字段的访问/修改\ntrace [go] methods [thread]\n                          -- 跟踪方法进入和退出。\n                          -- 除非指定 'go', 否则挂起所有线程\ntrace [go] method exit | exits [thread]\n                          -- 跟踪当前方法的退出, 或者所有方法的退出\n                          -- 除非指定 'go', 否则挂起所有线程\nuntrace [methods]         -- 停止跟踪方法进入和/或退出\nstep                      -- 执行当前行\nstep up                   -- 一直执行, 直到当前方法返回到其调用方\nstepi                     -- 执行当前指令\n下一步                      -- 步进一行 (步过调用)\ncont                      -- 从断点处继续执行\n\nlist [line number|method] -- 输出源代码\nuse (或 sourcepath) [source file path]\n                          -- 显示或更改源路径\nexclude [<class pattern>, ... | \"none\"]\n                          -- 对于指定的类, 不报告步骤或方法事件\nclasspath                 -- 从目标 VM 输出类路径信息\n\nmonitor <command>         -- 每次程序停止时执行命令\nmonitor                   -- 列出监视器\nunmonitor <monitor#>      -- 删除监视器\nread <filename>           -- 读取并执行命令文件\n\nlock <expr>               -- 输出对象的锁信息\nthreadlocks [thread id]   -- 输出线程的锁信息\n\npop                       -- 通过当前帧出栈, 且包含当前帧\nreenter                   -- 与 pop 相同, 但重新进入当前帧\nredefine <class id> <class file name>\n                          -- 重新定义类的代码\n\ndisablegc <expr>          -- 禁止对象的垃圾收集\nenablegc <expr>           -- 允许对象的垃圾收集\n\n!!                        -- 重复执行最后一个命令\n<n> <command>             -- 将命令重复执行 n 次\n# <command>               -- 放弃 (无操作)\nhelp (或 ?)               -- 列出命令\nversion                   -- 输出版本信息\nexit (或 quit)            -- 退出调试器\n\n<class id>: 带有程序包限定符的完整类名\n<class pattern>: 带有前导或尾随通配符 ('*') 的类名\n<thread id>: 'threads' 命令中报告的线程编号\n<expr>: Java(TM) 编程语言表达式。\n支持大多数常见语法。\n\n可以将启动命令置于 \"jdb.ini\" 或 \".jdbrc\" 中\n位于 user.home 或 user.dir 中" }, { "zz usage text", "用法: {0} <options> <class> <arguments>\n\n其中, 选项包括:\n    -help             输出此消息并退出\n    -sourcepath <由 \"{1}\" 分隔的目录>\n                      要在其中查找源文件的目录\n    -attach <address>\n                      使用标准连接器附加到指定地址处正在运行的 VM\n    -listen <address>\n                      等待正在运行的 VM 使用标准连接器在指定地址处连接\n    -listenany\n                      等待正在运行的 VM 使用标准连接器在任何可用地址处连接\n    -launch\n                      立即启动 VM 而不是等待 ''run'' 命令\n    -listconnectors   列出此 VM 中的可用连接器\n    -connect <connector-name>:<name1>=<value1>,...\n                      使用所列参数值通过指定的连接器连接到目标 VM\n    -dbgtrace [flags] 输出信息供调试{0}\n    -tclient          在 HotSpot(TM) 客户机编译器中运行应用程序\n    -tserver          在 HotSpot(TM) 服务器编译器中运行应用程序\n\n转发到被调试进程的选项:\n    -v -verbose[:class|gc|jni]\n                      启用详细模式\n    -D<name>=<value>  设置系统属性\n    -classpath <由 \"{1}\" 分隔的目录>\n                      列出要在其中查找类的目录\n    -X<option>        非标准目标 VM 选项\n\n<class> 是要开始调试的类的名称\n<arguments> 是传递到 <class> 的 main() 方法的参数\n\n要获得命令的帮助, 请在{0}提示下键入 ''help''" } };
/*    */   }
/*    */ }


/* Location:              C:\Program Files\Java\jdk1.8.0_211\lib\tools.jar!\com\sun\tools\example\debug\tty\TTYResources_zh_CN.class
 * Java compiler version: 8 (52.0)
 * JD-Core Version:       1.1.3
 */